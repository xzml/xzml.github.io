{"pages":[{"title":"About","date":"2018-11-25T02:31:40.664Z","path":"about/index.html","text":""},{"title":"Tags","date":"2018-11-25T02:31:40.667Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2018-11-25T02:31:40.665Z","path":"categories/index.html","text":""}],"posts":[{"title":"常见问题与处理方法","date":"2020-03-31T14:50:24.000Z","path":"wiki/某些Tricks/常见问题与处理方法/","text":"常见问题与处理方法目的: 一般遇到软件运行错误, 常常 Google 得到解决办法, 这里记录一下遇到的问题以及解决方法. 问题: 使用命令 hexo new 或者 hexo generate 或者 hexo deploy 时报错: 1dyld: Library not loaded: /usr/local/opt/icu4c/lib/libicui18n.62.dylib 解决方法: 参考 https://stackoverflow.com/questions/53828891/dyld-library-not-loaded-usr-local-opt-icu4c-lib-libicui18n-62-dylib-error-run 使用: 1brew upgrade node 更新一下 node 即可. 参考资料","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"pybind11使用demo","date":"2019-09-07T06:51:06.000Z","path":"wiki/程序语言/Python/PyBind11/pybind11使用demo/","text":"为了让我们写的 C++ 代码能够在 Python 中被调用, pybind11 提供了大量 API 来实现这一目标. 本文给出一个 minimal demo 来介绍 pybind11 的基本使用方法. 文件结构介绍这个 demo 包含如下的文件, 其中: utils 目录中保存的是我们写的 C++ 程序; pybind 目录则是利用 Pybind11 提供的功能来实现 Python 调用 C++ 程序; package.so 是编译 pybind/ 中的内容后得到的 Python 包, 可以使用 import package 调用; test.py 用来测试 Python 是否能正常使用编译后的 package.so; Makefile 用来组织整个工程. 123456789101112.├── Makefile├── package.so├── pybind│ ├── add.cc│ ├── subtract.cc│ ├── main.cc│ └── package.h├── test.py└── utils ├── add.cc └── add.h 下面依次介绍上面的列出的文件. C++ 程序首先介绍底层 C++ 代码, 其中 add.h 中声明了几个简单的函数: 12345678#ifndef _UTILS_ADD_H#define _UTILS_ADD_Hint add(int, int);double add(double, double);int subtract(int, int);#endif 在 add.cc 中对这些函数进行实现: 12345678910111213#include \"add.h\"int add(int a, int b) &#123; return a + b;&#125;double add(double a, double b) &#123; return a + b;&#125;int subtract(int a, int b) &#123; return a - b;&#125; 在写这些代码时, 我们无需考虑之后 Python 中如何调用, 只需要用 C++ 实现所需的功能. 之后专门创建一个文件夹, 比如 pybind/, 来处理 C++ 和 Python 交互的事宜, 以避免相互干扰. 利用 Pybind11 构建 Python 接口pybind 的目录原本可以更为简单, 只用一个文件就可以实现所需的功能, 但按下面这种形式来划分, 代码结构会更为清晰. 其中 add.cc 和 subtract.cc 分别实现向 Python 提供加法和减法操作, 而 main.cc 实现在 Python 中提供 package 这个包. 此外这样组织代码还可以减少编译时间, 具体参考: How can I reduce the build time? 12345├── pybind│ ├── add.cc│ ├── subtract.cc│ ├── main.cc│ └── package.h 首先看 package.h 中的代码: 123456789101112131415#ifndef _PACKAGE_H#define _PACKAGE_H#include &lt;pybind11/pybind11.h&gt;#include &lt;pybind11/stl.h&gt;#include &lt;pybind11/stl_bind.h&gt;#include \"utils/add.h\"namespace py = pybind11;void init_add(py::module &amp;);void init_sub(py::module &amp;);#endif 主要是导入 pybind11 的相关头文件, 并按照 How can I reduce the build time? 中介绍的方式提供两个以 py::module &amp; 作为参数的函数; 此外, 为了和前面写的 C++ 程序交互, 需要导入对应的头文件 utils/add.h. 再来看 add.cc 以及 subtract.cc 的实现: 123456#include \"package.h\"void init_add(py::module &amp;m) &#123; m.def(\"add\", (int (*)(int, int))&amp;add, \"add two int numbers\"); m.def(\"add\", (double (*)(double, double))&amp;add, \"add two double numbers\");&#125; 以及 12345#include \"package.h\"void init_sub(py::module &amp;m) &#123; m.def(\"subtract\", (int (*)(int, int))&amp;subtract, \"subtract two int numbers\");&#125; 最后使用 main.cc 提供到 Python 的入口, build package 这个 module: 123456#include \"package.h\"PYBIND11_MODULE(package, m) &#123; init_add(m); init_sub(m);&#125; 编写测试文件如果 package.so 编译成功, 那么在 Python 中就能正常使用: 12345import packageprint(package.add(1, 2))print(package.add(1.0, 2.0))print(package.subtract(1, 2)) 编译模块, Makefile 文件的编写感觉写 C++ 代码最难的事情之一应该包括 Makefile 的编写, 先将代码贴出来, 再慢慢解析: 123456789101112131415161718192021222324NAME := packageSRC := $(shell find pybind -name \"*.cc\")TAR := $(NAME).soINCLUDE_DIRS := $(dir .)INCLUDE_DIRS += $(shell find utils -depth 0) INCLUDE_DIRS += $(shell find pybind -depth 0) CXX_SRCS := $(shell find utils -name \"*.cc\")CXX_OBJS := $(CXX_SRCS:.cc=.o)CXX := clang++CXXFLAGS := -Wall -std=c++0x -shared -fPIC -Wl,-undefined,dynamic_lookupCXXFLAGS += $(foreach includedir,$(INCLUDE_DIRS),-I$(includedir))CXXFLAGS += $(foreach includedir,$(INCLUDE_DIRS),-L$(includedir))CXXFLAGS += `python -m pybind11 --includes`CXXLINKS :=$(TAR) : $(SRC) $(CXX_OBJS) $(CXX) $(CXXFLAGS) -o $@ $^ $(CXXLINKS).PHONY : cleanclean : rm -rf $(CXX_OBJS) $(TAR) package.so 依赖的文件是 pybind/ 目录下的 pybind11 代码(使用 $(SRC) 表示)以及 utils/ 中的 C++ 代码(使用 $(CXX_OBJS) 表示); 根据 跟我一起写 Makefile 9.3 节 “隐含规则使用的变量” 中的介绍, 像 CXX, CXXFLAGS 是 make 定义的隐含规则的变量, 需要注意. 编译成 .so 文件需要使用 -shared -fPIC; 此外在 Mac 下编译还需要加上 -Wl,-undefined,dynamic_lookup(参考 https://github.com/pybind/pybind11/issues/382); $(CXX_OBJS) 会通过 make 的隐含规则进行编译, 它们是 utils/ 目录下 C++ 代码编译后的目标文件; 最后用 $(CXX) $(CXXFLAGS) -o $@ $^ $(CXXLINKS) 编译并链接生成 package.so. 运行测试文件运行测试文件 test.py, 能正常使用. 1233 │ ~3.0 │ ~-1 参考资料 跟我一起写 Makefile How can I reduce the build time? https://github.com/pybind/pybind11/issues/382","tags":[{"name":"PyBind11","slug":"PyBind11","permalink":"http://yoursite.com/tags/PyBind11/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"PyBind11","slug":"程序语言/Python/PyBind11","permalink":"http://yoursite.com/categories/程序语言/Python/PyBind11/"}]},{"title":"Hive使用","date":"2019-07-28T13:16:32.000Z","path":"wiki/大数据相关/Hive/Hive使用/","text":"Hive 设置大多数的Hadoop job是需要hadoop提供的完整的可扩展性来处理大数据的。不过，有时hive的输入数据量是非常小的。在这种情况下，为查询出发执行任务的时间消耗可能会比实际job的执行时间要多的多。对于大多数这种情况，hive可以通过本地模式在单台机器上处理所有的任务。对于小数据集，执行时间会明显被缩短。如此一来，对数据量比较小的操作，就可以在本地执行，这样要比提交任务到集群执行效率要快很多。 配置如下参数，可以开启Hive的本地模式： 12-- 默认为 falseset hive.exec.mode.local.auto=true; 当一个job满足如下条件才能真正使用本地模式： 1.job的输入数据大小必须小于参数：hive.exec.mode.local.auto.inputbytes.max(默认128MB)2.job的map数必须小于参数：hive.exec.mode.local.auto.tasks.max(默认4)3.job的reduce数必须为0或者1 加载数据加载本地数据例子1123456789101112131415161718192021222324252627-- 创建数据库CREATE DATABASE IF NOT EXISTS test;-- 显示数据库SHOW DATABASES;DESCRIBE DATABASE test;-- 删除表DROP TABLE IF EXISTS test.stu1;-- 创建表CREATE TABLE IF NOT EXISTS test.stu1 ( name STRING COMMENT 'student name', gender STRING COMMENT 'student gender', age INT COMMENT 'student age', sno STRING COMMENT 'student number')ROW FORMAT DELIMITEDFIELDS TERMINATED BY ',';-- 加载本地数据(使用 OVERWRITE 会覆盖数据), 本地数据见下面LOAD DATA LOCAL INPATH './mydata/student.txt'OVERWRITE INTO TABLE test.stu1;-- 统计 (其实我就是想使用一个 GROUP BY)SELECT name, gender, sum(case when gender='boy' then 1 else 0 end)FROM test.stu1; 例子1 中的数据./mydata/student.txt 数据. 12345678alex,boy,19,123bob,boy,20,124cool,girl,22,125dodo,boy,21,126bob,boy,22,127alex,boy,22,128else,girl,19,129mary,girl,20,130 从 HDFS 中载入数据其实从本地载入数据到 hive 表的过程中, 其实是先将数据临时复制到HDFS的一个目录下（典型的情况是复制到上传用户的HDFS home目录下,比如/home/wyp/），然后再将数据从那个临时目录下移动（注意，这里说的是移动，不是复制！）到对应的Hive表的数据目录里面。既然如此，那么Hive肯定支持将数据直接从HDFS上的一个目录移动到相应Hive表的数据目录下. 先将数据上传到 HDFS 中 123hadoop fs -mkdir /mydatahadoop fs -mkdir /mydata/studenthadoop fs -put ./mydata/student.txt /mydata/student 然后在 HIVE 中使用: 12345678910111213141516DROP TABLE IF EXISTS test.stu2;CREATE TABLE IF NOT EXISTS test.stu2 ( name STRING COMMENT 'student name', gender STRING COMMENT 'student gender', age INT COMMENT 'student age', sno STRING COMMENT 'student number')ROW FORMAT DELIMITEDFIELDS TERMINATED BY ',';-- 加载HDFS数据(使用 OVERWRITE 会覆盖数据), 这里面没有 LOCAL 这个关键字LOAD DATA LOCAL INPATH '/mydata/student/student.txt'OVERWRITE INTO TABLE test.stu2;SELECT name, gender, sum(case when gender='boy' then 1 else 0 end)FROM test.stu2; 从其他表中查询数据并导入到 Hive 表中12345678910111213141516DROP TABLE IF EXISTS test.stu3;-- 注意这里没有了 ageCREATE TABLE IF NOT EXISTS test.stu3 ( name STRING COMMENT 'student name', gender STRING COMMENT 'student gender', sno STRING COMMENT 'student number')ROW FORMAT DELIMITEDFIELDS TERMINATED BY ',';-- 从 stu2 表中导入数据INSERT INTO TABLE test.stu3SELECT name, gender, sno FROM test.stu2;SELECT name, gender, sum(case when gender='boy' then 1 else 0 end)FROM test.stu2; 在创建表的时候通过其他表插值在实际情况中，表的输出结果可能太多，不适于显示在控制台上，这时候，将Hive的查询输出结果直接存在一个新的表中是非常方便的，我们称这种情况为CTAS（create table .. as select）如下: 12CREATE TABLE IF NOT EXISTS test.stu4 ASSELECT * FROM test.stu3; 导出数据将数据导出到本地12INSERT OVERWRITE LOCAL DIRECTORY './tmp/'SELECT * FROM test.stu1; 将数据导出到HDFS12INSERT OVERWRITE DIRECTORY '/mydata/stu2'SELECT * FROM test.stu2; Hive 中的函数函数信息12345678-- 显示当前会话有多少函数可用SHOW FUNCTIONS;-- 显示函数的描述信息DESC FUNCTION concat;-- 显示函数的扩展描述信息 DESC FUNCTION EXTENDED concat; 参考资料 Hive的几种常见的数据导入方式 Hive的内置函数 Hive group by操作","tags":[{"name":"Hive","slug":"Hive","permalink":"http://yoursite.com/tags/Hive/"}],"categories":[{"name":"大数据相关","slug":"大数据相关","permalink":"http://yoursite.com/categories/大数据相关/"},{"name":"Hive","slug":"大数据相关/Hive","permalink":"http://yoursite.com/categories/大数据相关/Hive/"}]},{"title":"Bash技巧","date":"2019-05-25T12:47:33.000Z","path":"wiki/技术开发/Unix/Ubuntu/Bash技巧/","text":"文件与目录操作copy files except one[BASH copy all files except one][https://stackoverflow.com/questions/1313590/bash-copy-all-files-except-one] 使用 rsync, 真的非常好用. 1234rsync -av from/ to/ --exclude=Default.png-a, --archive archive mode; equals -rlptgoD (no -H,-A,-X)-v, --verbose increase verbosity 实例: 当时我想将当前目录下的文件与目录拷贝到当前目录下的 Github 目录中, 使用: 1rsync -av * Github --exclude=Github 参考资料","tags":[{"name":"Unix","slug":"Unix","permalink":"http://yoursite.com/tags/Unix/"},{"name":"Bash","slug":"Bash","permalink":"http://yoursite.com/tags/Bash/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"Unix","slug":"技术开发/Unix","permalink":"http://yoursite.com/categories/技术开发/Unix/"},{"name":"Ubuntu","slug":"技术开发/Unix/Ubuntu","permalink":"http://yoursite.com/categories/技术开发/Unix/Ubuntu/"}]},{"title":"绘制3D图像","date":"2019-05-13T15:24:07.000Z","path":"wiki/程序语言/Python/Matplotlib/绘制3D图像/","text":"绘制 3D 柱状图 Bar12345678910111213141516171819202122232425fig, ax = plt.subplots(subplot_kw=&#123;'projection': '3d'&#125;)# 控制视角, 其中 elev 控制 z 方向的视角, 而 azim 控制 xy 平面的视角ax.view_init(elev=10, azim=-80) x = np.array([1, 2, 3, 4])y = np.array([1])# 若 x \\in R^m, y\\in R^n, 那么 xx 和 yy 的结果都是 R^&#123;n \\times m&#125;xx, yy = np.meshgrid(x, y)print(xx.shape, yy.shape)data = xx * yyz = np.zeros(data.size)# bar 的宽度dx = 0.45 * np.ones(data.size)dy = 0.4 * np.ones(data.size)dz = [1, 2, 3, 4]ax.set_xlim(0, 8)ax.set_ylim(0, 4)ax.yaxis.set_visible(False)ax.get_yaxis().set_ticks([])ax.set_zlim(0, 5)## xx.flatten(), yy.flatten(), z 在 xx 和 yy 围成的区域中进行描点, z 是在 z 轴方向描点,## 但是 bar 是宽度的, 因此用 dx, dy, dz 来设置它们的宽度. 比如 dx[0] 表示第一个点的在 x 方向的## 宽度是 0.45.ax.bar3d(xx.flatten(), yy.flatten(), z, dx, dy, dz, cmap=cm.coolwarm)print(ax.azim) 绘制 3D 圆柱 Cylinder123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132from math import sin, cosimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltfrom matplotlib import cmfrom matplotlib.transforms import Bboximport numpyfrom os.path import joinimport matplotlib as mpldef plot_cylinder_element(x, z, dz, rx = 5, ry = 5, color = \"b\"): \"\"\" x: left, right z: start height dz: height of cylinder rx, ry = radius of width (x) and depth (y) color = color Inspired by:http://matplotlib.1069221.n5.nabble.com/plot-surface-shading-and-clipping-error-td14031.html \"\"\" N = 50 # number of elements # a lower stride will give more faces. A cylinder with 4 faces is a cube :) # I think with N=100 and rstride=2, it will have 50 faces # cstride is the height, rstride the circle cstride_side = 1000 # only 1 element needed rstride_side = 1 # many elements to make a nice cylinder shape cstride_top = 10 rstride_top = 10 # parameters of cylinder phi = numpy.linspace(0, 2 * numpy.pi, N) _r = numpy.ones(N) _h = numpy.linspace(0, 1, N) # cylinder _x = rx * numpy.outer(numpy.cos(phi), _r) + x _y = ry * numpy.outer(numpy.sin(phi), _r) _z = dz * numpy.outer(numpy.ones(numpy.size(_r)), _h) + z ax.plot_surface(_x, _y, _z, rstride = rstride_side, cstride = cstride_side, linewidth = 0, alpha = 1, color = color) # to cover the gaps between the faces, plot the cylinder again at a slightly smaller radius _x *= 0.99 _y *= 0.99 ax.plot_surface(_x, _y, _z, rstride = rstride_side + 1, cstride = cstride_side + 1, linewidth=0, alpha=1, color = color) # top _x = rx * numpy.outer(numpy.cos(phi), _h) + x _y = ry * numpy.outer(numpy.sin(phi), _h) _z = numpy.zeros([N,N]) + z + dz + 0.01 ax.plot_surface(_x, _y, _z, rstride = rstride_top, cstride = cstride_top, linewidth = 0, alpha = 1, color = color) # plot again with different stride to mask the gaps ax.plot_surface(_x, _y, _z, rstride = rstride_side + 1, cstride = cstride_side + 1, linewidth=0, alpha=1, color = color) def plot_cylinder(x, z, rx = 5, ry = 5): \"\"\" x: left-right for each cylinder z: list height difference (ie. not cumulative) \"\"\" # list with colors colors = [\"b\", \"g\", \"r\", \"c\", \"y\", \"k\"] # plot cylinder elements _z = 0 for i in range(len(z)): plot_cylinder_element(x, _z, z[i], rx = rx, ry = ry, color = colors[i % len(colors)]) _z += z[i]def cylinder_plot(z, r = 10, dr = 30): \"\"\" z: list of different cylinders with for each a list height difference (ie. not cumulative) r: radius dr: distance between cylinders \"\"\" # different cylinders next to each other x = numpy.arange(len(z)) * dr # possible difference between width (x) and depth (y) rx = r ry = r # make cylinders for i in range(len(z)): plot_cylinder(x[i], z[i], rx = rx, ry = ry)fig, ax = plt.subplots(subplot_kw=&#123;'projection': '3d'&#125;)unit = 100dpi = 6 * unitwidth = 8 * dpi# height = 0.818 * widthheight = 0.408 * widthmargin = 0figsize = ((width + 2 * margin) / dpi, (height + 2 * margin) / dpi)left = margin /dpi / figsize[0]bottom = margin / dpi / figsize[1]fig.set_size_inches(figsize[0], figsize[1])# 控制视角, 其中 elev 控制 z 方向的视角, 而 azim 控制 xy 平面的视角ax.view_init(elev=10, azim=-80)ax.set_xlim(-30, 240)ax.set_ylim(-20, 80)# ax.set_zlim(26, 34)ax.yaxis.set_visible(False)ax.get_yaxis().set_ticks([])ax.zaxis.set_ticklabels([26, 27, 28, 29, 30, 31, 32])# print(ax.get_zticks())r = 10dr = 45 # distance between cylinders labels = ['Bicubic', 'ScSR', 'CSC-SR', 'VDSR', 'EDSR', 'RDN']# ScSR 的结果来自 https://github.com/jbhuang0604/SelfExSRplt.xticks([-5, 35, 85, 125, 175, 215], labels, rotation=35, horizontalalignment='right', rotation_mode='anchor', fontweight='bold')# cylinder_plot([[28.42], [29.07], [30.36], [31.35], [32.46], [32.47]], r, dr) # zmin=26xdis = [-30, 15, 60, 105, 150, 195]for i in range(len(xdis)): xdis[i] += 20ax.text(xdis[0], 0, 2.8, '28.42', fontsize=10, fontweight='bold')ax.text(xdis[1], 0, 3.4, '29.07', fontsize=10, fontweight='bold')ax.text(xdis[2], 0, 4.7, '30.36', fontsize=10, fontweight='bold')ax.text(xdis[3], 0, 5.7, '31.35', fontsize=10, fontweight='bold')ax.text(xdis[4], 0, 6.8, '32.46', fontsize=10, fontweight='bold')ax.text(xdis[5], 0, 6.9, '32.47', fontsize=10, fontweight='bold')cylinder_plot([[2.42], [3.07], [4.36], [5.35], [6.46], [6.47]], r, dr) save_path = '/Users/zhang/Nutstore Files/Nutstore/ThesisPaper/答辩报告/figures'# save_path = '.'# plt.savefig(join(save_path, 'psnr_3d_cylinder.pdf'), dpi=dpi, bbox_inches=Bbox(np.array([[1.9, 0.25], [6.5, 2.5]])), pad_inches=0)plt.show() 更为简单的使用方法是: 123456789fig, ax = plt.subplots(subplot_kw=&#123;'projection': '3d'&#125;)# 控制视角, 其中 elev 控制 z 方向的视角, 而 azim 控制 xy 平面的视角ax.view_init(elev=10, azim=-80)ax.set_xlim(-30, 80)ax.set_ylim(-10, 40)ax.yaxis.set_visible(False)ax.get_yaxis().set_ticks([])cylinder_plot([[10], [5], [2]])plt.show() 参考资料 Creating a stacked cylinder bar plot in matplotlib 3d bar 3d surface Plotting circular 3d bars (discs) using matplotlib","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://yoursite.com/tags/Matplotlib/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"Matplotlib","slug":"程序语言/Python/Matplotlib","permalink":"http://yoursite.com/categories/程序语言/Python/Matplotlib/"}]},{"title":"pytorch-grad","date":"2019-05-13T15:12:58.000Z","path":"wiki/程序语言/Python/PyTorch/pytorch-grad/","text":"PyTorch 的自动求导先看一个小例子: 1234567891011121314151617import torchfrom torch.autograd import Variableimport torch.nn as nnx = Variable(torch.ones(1, 2), requires_grad=True)linear = nn.Linear(2, 2, bias=False)linear.weight.data.copy_(torch.Tensor([[1, 2], [1, 2]]))y = xfor i in range(2): y = linear(y)loss = y.sum()loss.backward()print(linear.weight.grad)print(x.grad) 其中 $y = W\\cdot(W\\cdot x)$, 使用 .backward() 即可自动求导了. 参考资料","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://yoursite.com/tags/PyTorch/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"PyTorch","slug":"程序语言/Python/PyTorch","permalink":"http://yoursite.com/categories/程序语言/Python/PyTorch/"}]},{"title":"有关vncserver","date":"2019-04-27T04:55:14.000Z","path":"wiki/某些Tricks/有关vncserver/","text":"VNCserver参考资料非常详细了, 这里简要概括一下. 安装 vncserver12sudo apt-get install gnome-coresudo apt-get install vnc4server 使用如下命令在某用户目录开启 vncserver, 并设置密码: 12cd ~/usernamevncserver 关闭 vncserver, 冒号后面是端口号: 1vncserver -kill :1 为了用上 xfce4 桌面, 需要修改 xstartup 文件, 该文件在 ~/.vnc 目录下, 这个目录需要先运行 vncserver 命令才会生成: 12cd ~/username/.vncvim xstartup 修改成如下形式: 1234567891011121314#!/bin/sh # Uncomment the following two lines for normal desktop:unset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESSstartxfce4 &amp;# exec /etc/X11/xinit/xinitrc[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresourcesxsetroot -solid greyvncconfig -iconic &amp;# x-terminal-emulator -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" &amp;# x-window-manager &amp; 之后重新开启 vncserver: 1vncserver -geometry 1024x600 开机启动 vncserver首先在 /etc/ 目录下创建一下文件: 12sudo mkdir -p /etc/vncserversudo vim /etc/vncserver/vncservers.conf vncservers.conf 内容如下: 123VNCSERVERS=\"1:arbab 2:ieric\"VNCSERVERARGS[1]=\"-geometry 1024x600 -depth 24\"VNCSERVERARGS[2]=\"-geometry 1024x600 -depth 24\" 有新用户加入就按上面的格式增加新的用户名以及设置 vncserver 启动的参数. 下面设置开机启动的脚本, 首先在 /etc/init.d 目录下创建名为 vncserver 的脚本: 123sudo touch /etc/init.d/vncserversudo chmod +x /etc/init.d/vncserversudo vim /etc/init.d/vncserver 开机启动的脚本来自: https://superuser.com/questions/147109/automatically-start-vnc-server-on-startup, 将下面内容写进 vncserver 文件中: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/bin/bashunset VNCSERVERARGSVNCSERVERS=\"\"[ -f /etc/vncserver/vncservers.conf ] &amp;&amp; . /etc/vncserver/vncservers.confprog=$\"VNC server\"start() &#123; . /lib/lsb/init-functions REQ_USER=$2 echo -n $\"Starting $prog: \" ulimit -S -c 0 &gt;/dev/null 2&gt;&amp;1 RETVAL=0 for display in $&#123;VNCSERVERS&#125; do export USER=\"$&#123;display##*:&#125;\" if test -z \"$&#123;REQ_USER&#125;\" -o \"$&#123;REQ_USER&#125;\" == $&#123;USER&#125; ; then echo -n \"$&#123;display&#125; \" unset BASH_ENV ENV DISP=\"$&#123;display%%:*&#125;\" export VNCUSERARGS=\"$&#123;VNCSERVERARGS[$&#123;DISP&#125;]&#125;\" su $&#123;USER&#125; -c \"cd ~$&#123;USER&#125; &amp;&amp; [ -f .vnc/passwd ] &amp;&amp; vncserver :$&#123;DISP&#125; $&#123;VNCUSERARGS&#125;\" fi done&#125;stop() &#123; . /lib/lsb/init-functions REQ_USER=$2 echo -n $\"Shutting down VNCServer: \" for display in $&#123;VNCSERVERS&#125; do export USER=\"$&#123;display##*:&#125;\" if test -z \"$&#123;REQ_USER&#125;\" -o \"$&#123;REQ_USER&#125;\" == $&#123;USER&#125; ; then echo -n \"$&#123;display&#125; \" unset BASH_ENV ENV export USER=\"$&#123;display##*:&#125;\" su $&#123;USER&#125; -c \"vncserver -kill :$&#123;display%%:*&#125;\" &gt;/dev/null 2&gt;&amp;1 fi done echo -e \"\\n\" echo \"VNCServer Stopped\"&#125;case \"$1\" instart)start $@;;stop)stop $@;;restart|reload)stop $@sleep 3start $@;;condrestart)if [ -f /var/lock/subsys/vncserver ]; thenstop $@sleep 3start $@fi;;status)status Xvnc;;*)echo $\"Usage: $0 &#123;start|stop|restart|condrestart|status&#125;\"exit 1esac 注意: 每个用户都要手动开启 vncserver, 即重启之前, vncserver 在该用户目录下一定要是运行状态. 最后再执行: 1sudo update-rc.d vncserver defaults 99 现在重启 vncserver: 1sudo service vncserver restart 如果添加新的用户, 那么可以: 123456789sudo adduser newusersu - newuservncserver # 在 ~/newuser 目录下开启 vncservervim ~/.vnc/xstartup # 修改 xstartup 文件, 用上面介绍的 xstartup 内容替换, 使用 xfce4 桌面sudo vim /etc/vncserver/vncserver.conf # 在配置文件中增加新用户, 用于开机启动# 如果不想重启所有人的 vncserver, 可以到新用户目录下使用:cd ~/newuser; vncserver -kill :3; vncserver # 进行重启# 下面命令会重启所有人的 vncserversudo service vncserver restart # 重启 vncserver 参考资料 How to install VNC server on Ubuntu Server 12.04 multiple users on vnc","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"网络在线课程学习.md","date":"2019-04-26T05:41:39.000Z","path":"wiki/网络资源/网络在线课程学习/","text":"机器学习 台湾交通大学应用数学系 李育杰老师 机器学习当时我在 YouTube 上看到他介绍 SMO 算法, 思路清晰, 决定再将他其他课程再研究一下. 计算机系统 深入理解计算机系统 CMU 15-213 Introduction to Computer Systems 在线课程书签在 常用 -&gt; Computer System 中. Github 上对国外计算机科学课程的汇总非常详细… 参考资料","tags":[{"name":"Resource","slug":"Resource","permalink":"http://yoursite.com/tags/Resource/"}],"categories":[{"name":"网络资源","slug":"网络资源","permalink":"http://yoursite.com/categories/网络资源/"}]},{"title":"数据集下载和处理","date":"2019-04-14T13:46:23.000Z","path":"wiki/深度学习/数据集下载和处理/","text":"最近在考虑一个问题, 现在 PyTorch 等框架将网络训练整个流程都封装的很好, 比如数据下载, 预处理等等, 我在想如果以后遇到了非标准的数据集那该怎么办, 因此非常有必要自己将数据处理的部分从头动手做一遍, 于是有了下面的代码. 代码剖析完整代码可以看下一节, 这节对其中的细节作分析. 下载数据并解压1234567891011121314151617181920212223242526272829## progress bar of download_urldef gen_bar_updater(): pbar = tqdm(total=None) def bar_update(count, block_size, total_size): if pbar.total is None and total_size: pbar.total = total_size ## `count` is incremental, progress_bytes = count * block_size ## `pbar.n`: current state of the bar pbar.update(progress_bytes - pbar.n) return bar_updatedef download_url(url, root, filename=None): if not os.path.exists(root): os.makedirs(root) if not filename: filename = os.path.basename(url) fpath = os.path.join(root, filename) if os.path.exists(fpath): print('&#123;&#125; exists, no need downloding!'.format(filename)) else: print('Downloading &#123;&#125; to &#123;&#125;'.format(url, fpath)) urllib.request.urlretrieve(url, fpath, reporthook=gen_bar_updater()) extract_gzip(fpath, remove_finished=False) 使用 urllib 中的 urlretrieve 对 url 中的数据进行下载并保存到 fpath 路径, 其中 reporthook 参数接受一个函数对象, 该函数对象需要包含 (count, block_size, total_size) 三个参数, 因此该代码使用 gen_bar_updater 来产生该函数对象, 这样在下载数据时就会有一个进度条. 在 gen_bar_updater 中, count 在每次更新都会变化, 进度条当前的位置为 pbar.n, 而下一步要变化到 progress_bytes, 因此当前更新中, 进度条需要前进 progress_bytes - pbar.n. 通过这个小知识, 可以了解 tqdm 大致是怎么运作的. if os.path.exists(fpath) 表示, 如果数据已经下载, 那么可以不用处理, 直接去解压 编写 extract_gzip() 函数来解压文件, 其中使用 gzip 包来处理 *.gz 文件, 使用 tarfile 包来处理 *.tar.gz 文件, 但是 tarfile 应该也可以处理 *.gz 文件… extract_gzip 这里就不详细介绍了. 当将数据解压好后, 需要将数据读入内存, 最后将数据保存为大小为 (N, C, H, W) 的 Torch Tensor. 根据数据集是 MNIST 还是 CIFAR 需要分开处理. MNISTMNIST 的网址是 http://yann.lecun.com/exdb/mnist/ 根据网站中的介绍, MNIST 的训练数据 train-images-idx3-ubyte 是这样组织的: 首先, 肯定是以二进制的形式读取 train-images-idx3-ubyte 的: 其中前 4 位为 magic number, 4~8 为图像数量, 8~12 为行数, 12~16 为列数, 最后剩下的位为图像自身的像素, np.frombuffer 可以直接解析这些二进制位, 注意其中的参数 offset. 此外, 为了得到图像数量等, 还使用了 get_int, 它可以将二进制位转换为整数, 首先将二进制编码为十六进制 hex, 然后转换为 10 进制. (发现好多函数自己真的不熟啊), 最后通过 torch.from_numpy 将 numpy 数组转换为 Tensor. 读取 label 同理, 但是需要注意一个问题, label 的类型是 `LongTensor`!!!! 123456789101112def get_int(b): return int(codecs.encode(b, 'hex'), 16)def read_image_file(path): with open(path, 'rb') as f: data = f.read() assert get_int(data[:4]) == 2051 num_images = get_int(data[4 : 8]) num_rows = get_int(data[8 : 12]) num_cols = get_int(data[12 : 16]) parsed = np.frombuffer(data, dtype=np.uint8, offset=16) return torch.from_numpy(parsed).view(num_images, 1, num_rows, num_cols) 最终将 (data, labels) pair 保存到 mnist_train.pth 文件中: 12with open(os.path.join(path, data_file), 'wb') as f: torch.save(dataset, f) CIFARCIFAR 的网址是 https://www.cs.toronto.edu/~kriz/cifar.html CIFAR 解压后是一个新的目录: cifar-10-batches-py/, 看看官网的介绍: 数据文件分为好几个: data_batch_i 以及 test_batch, 官网给了读取数据的代码, 我们可以利用. 读取成功后是一个字典, 虽然上面说 key 有 data 以及 labels 等, 但实际上是 b&#39;data&#39;. 这里有个问题, 由于数据分成了好几个文件, 我要将它们组合成一个大的数据矩阵, 就需要将每个文件中的数据进行 concatenate, 如何优雅的写出这部分的代码呢? 如果以后有好的思路一定要记下来, 这里使用 list comprehension: 1234567891011121314151617181920212223def unpickle(datafile): import pickle with open(datafile, 'rb') as fo: data_dict = pickle.load(fo, encoding='bytes') return data_dictdef data_batch(i, path, key='data'): data_dict = unpickle(os.path.join(path, 'data_batch_&#123;&#125;'.format(i))) return data_dict[key]def prepare_dataset(...): ### ... data_array = np.concatenate( [data_batch(i, cifar_path, b'data') for i in range(1, 6)], axis=0 ) label_array = np.concatenate( [data_batch(i, cifar_path, b'labels') for i in range(1, 6)], axis=0 ) torch_data = torch.from_numpy(data_array).view(-1, 3, 32, 32) torch_label= torch.from_numpy(label_array).long() ### ... so easy! 最后将结果保存在 cifar_train/test.pth 中. 辅助代码查看图片这可以显示一个 array. 12345678910def show_array(array, show=False): array = np.array(array).transpose((1, 2, 0)) h, w, c = array.shape array = array.squeeze() if c &gt; 1: cmap = None else: cmap = 'gray' fig, ax = plt.subplots() ax.imshow(array, cmap=cmap) if show: plt.show() 需要注意两个问题: 对于灰度图, 将数组大小转换为 (h, w, 1) 在扔进 imshow 中是会报错的, 因此需要使用 squeeze() 去掉 1 这个 dimension. 如果是显示灰度图, cmap 可以设置为 gray 查看一组图片显示一组 arrays 123456789101112131415def show_grid(arrays, n_cols=8, cmap='gray', show=False): arrays = np.array(arrays).transpose((0, 2, 3, 1)) _, h, w, c = arrays.shape arrays = arrays.squeeze() if c &gt; 1: cmap = None else: cmap = 'gray' num = arrays.shape[0] m, n = num // n_cols, n_cols fig, axes = plt.subplots(m, n) axes = axes.ravel() for i in range(num): axes[i].set_axis_off() axes[i].imshow(arrays[i], cmap=cmap) if show: plt.show() 同理, 只是这里每行显示 n_cols 张图片. 完整代码参考了 https://github.com/pytorch/vision/tree/master/torchvision/datasets 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221import osfrom six.moves import urllibfrom tqdm import tqdmimport gzipimport tarfileimport codecsimport numpy as npimport torchimport matplotlibimport matplotlib.pyplot as plt## progress bar of download_urldef gen_bar_updater(): pbar = tqdm(total=None) def bar_update(count, block_size, total_size): if pbar.total is None and total_size: pbar.total = total_size progress_bytes = count * block_size ## `count` is incremental, ## `pbar.n`: current state of the bar pbar.update(progress_bytes - pbar.n) return bar_updatedef download_url(url, root, filename=None): if not os.path.exists(root): os.makedirs(root) if not filename: filename = os.path.basename(url) fpath = os.path.join(root, filename) if os.path.exists(fpath): print('&#123;&#125; exists, no need downloding!'.format(filename)) else: print('Downloading &#123;&#125; to &#123;&#125;'.format(url, fpath)) urllib.request.urlretrieve(url, fpath, reporthook=gen_bar_updater()) extract_gzip(fpath, remove_finished=False)def extract_gzip(gzip_path, remove_finished=False): # ofile = gzip_path.replace('.gz', '') components = gzip_path.split('/') if 'mnist' in gzip_path: components[-1] = components[-1].split('.')[0] elif 'cifar' in gzip_path: components[-1] = 'cifar-10-batches-py' ofile = '/'.join(components) if os.path.exists(ofile): print('&#123;&#125; exist!'.format(ofile)) else: print('Extracting &#123;&#125;'.format(gzip_path)) if 'mnist' in gzip_path: with open(ofile, 'wb') as out_file, \\ gzip.GzipFile(gzip_path) as in_file: out_file.write(in_file.read()) elif 'cifar' in gzip_path: tar = tarfile.open(gzip_path, \"r:gz\") tar.extractall(os.path.dirname(gzip_path)) tar.close() if remove_finished: os.remove(gzip_path)def get_int(b): return int(codecs.encode(b, 'hex'), 16)def read_image_file(path): with open(path, 'rb') as f: data = f.read() assert get_int(data[:4]) == 2051 num_images = get_int(data[4 : 8]) num_rows = get_int(data[8 : 12]) num_cols = get_int(data[12 : 16]) parsed = np.frombuffer(data, dtype=np.uint8, offset=16) return torch.from_numpy(parsed).view(num_images, 1, num_rows, num_cols)def read_label_file(path): with open(path, 'rb') as f: data = f.read() assert get_int(data[:4]) == 2049 num_images = get_int(data[4 : 8]) parsed = np.frombuffer(data, dtype=np.uint8, offset=8) return torch.from_numpy(parsed).view(num_images).long()def unpickle(datafile): import pickle with open(datafile, 'rb') as fo: data_dict = pickle.load(fo, encoding='bytes') return data_dictdef data_batch(i, path, key='data'): data_dict = unpickle(os.path.join(path, 'data_batch_&#123;&#125;'.format(i))) return data_dict[key]def prepare_dataset(name, path, Train=True): training_file = name + '_train.pth' testing_file = name + '_test.pth' if name == 'mnist': if Train: data_file = training_file img_name = 'train-images-idx3-ubyte' label_name = 'train-labels-idx1-ubyte' else: data_file = testing_file img_name = 't10k-images-idx3-ubyte' label_name = 't10k-labels-idx1-ubyte' if os.path.exists(os.path.join(path, data_file)): return dataset = ( read_image_file(os.path.join(path, img_name)), read_label_file(os.path.join(path, label_name)) ) with open(os.path.join(path, data_file), 'wb') as f: torch.save(dataset, f) elif name == 'cifar10': cifar_path = os.path.join(path, 'cifar-10-batches-py') if Train: data_file = training_file data_array = np.concatenate( [data_batch(i, cifar_path, b'data') for i in range(1, 6)], axis=0 ) label_array = np.concatenate( [data_batch(i, cifar_path, b'labels') for i in range(1, 6)], axis=0 ) torch_data = torch.from_numpy(data_array).view(-1, 3, 32, 32) torch_label= torch.from_numpy(label_array).long() else: data_file = testing_file data_dict = unpickle(os.path.join(cifar_path, 'test_batch')) data_array = data_dict[b'data'] label_array = np.array(data_dict[b'labels']) torch_data = torch.from_numpy(data_array).view(-1, 3, 32, 32) torch_label= torch.from_numpy(label_array).long() if os.path.exists(os.path.join(path, data_file)): return dataset = ( torch_data, torch_label, ) with open(os.path.join(path, data_file), 'wb') as f: torch.save(dataset, f)def show_array(array, show=False): array = np.array(array).transpose((1, 2, 0)) h, w, c = array.shape array = array.squeeze() if c &gt; 1: cmap = None else: cmap = 'gray' fig, ax = plt.subplots() ax.imshow(array, cmap=cmap) if show: plt.show()def show_grid(arrays, n_cols=8, cmap='gray', show=False): arrays = np.array(arrays).transpose((0, 2, 3, 1)) _, h, w, c = arrays.shape arrays = arrays.squeeze() if c &gt; 1: cmap = None else: cmap = 'gray' num = arrays.shape[0] m, n = num // n_cols, n_cols fig, axes = plt.subplots(m, n) axes = axes.ravel() for i in range(num): axes[i].set_axis_off() axes[i].imshow(arrays[i], cmap=cmap) if show: plt.show()if __name__ == '__main__': urls = [ 'http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz', 'http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz', 'http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz', 'http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz', ] for url in urls: download_url(url, 'data', filename=None) prepare_dataset('mnist', 'data', Train=True) prepare_dataset('mnist', 'data', Train=False) # with open('data/mnist_test.pth', 'rb') as f: # test_set = torch.load(f) # test_images, test_labels = test_set # print(test_images[0].numpy().shape) # show_array(test_images[0].numpy(), show=False) # show_grid(test_images[:16].numpy(), show=True) urls = [ 'https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz', ] for url in urls: download_url(url, 'data', filename=None) prepare_dataset('cifar10', 'data', Train=True) prepare_dataset('cifar10', 'data', Train=False) with open('data/cifar10_test.pth', 'rb') as f: test_set = torch.load(f) test_images, test_labels = test_set print(test_images[0].numpy().shape) show_array(test_images[0].numpy(), show=False) show_grid(test_images[:16].numpy(), show=True) 参考资料 pytorch torchvision:mnist.py","tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"}],"categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/categories/深度学习/"}]},{"title":"PyTorch-C++ 接口","date":"2019-04-14T04:01:00.000Z","path":"wiki/程序语言/Python/PyTorch/PyTorch-Cpp/","text":"介绍从 https://pytorch.org/ 下载 LibTorch 代码 Hello World写一个 Hello World 程序 123456789#include &lt;iostream&gt;#include &lt;torch/torch.h&gt;using namespace std;int main() &#123; torch::Tensor tensor = torch::rand(&#123;2, 2&#125;); cout &lt;&lt; tensor &lt;&lt; endl;&#125; 编译Makefile 如下: 其中 .../libtorch 中保存着 LibTorch 的代码 12345678910111213141516171819202122TORCH = /Users/zhang/Codes/C++/pytorch-c++/libtorchCC = clang++CFLAGS = -Wall -std=c++0xCFLAGS += -I$(TORCH)/include -L$(TORCH)/libCFLAGS += -I$(TORCH)/include/torch/csrc/api/includeCLINKS = -ltorch.1 -lcaffe2 -lc10NAME = ex1SRC = $(NAME).cppTAR = $(NAME).out$(TAR) : $(SRC) $(CC) $(CFLAGS) -o $@ $^ $(CLINKS).PHONY : run cleanrun : LD_LIBRARY_PATH=$(TORCH)/lib ./$(TAR)clean : rm -rf *.out 参考资料","tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"http://yoursite.com/tags/PyTorch/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"PyTorch","slug":"程序语言/Python/PyTorch","permalink":"http://yoursite.com/categories/程序语言/Python/PyTorch/"}]},{"title":"Docker常用命令","date":"2019-01-05T11:56:29.000Z","path":"wiki/技术开发/Docker/Docker常用命令/","text":"常用命令总结1234567891011121314151617# -t 表示 tag, -f 表示 file, 默认是 Dockerfile, 最后的 . 不要忘了docker build -t ubuntu-16.04:v1 -f Dockerfile.gpu .docker ps -adocker image lsdocker rm container_iddocker rmi image_iddocker run -v /path/of/host:/path/in/constainer -p /port/of/host:/port/of/container -it image_id [command]docker pull image_in_dockerhubdocker commit -a author -m message container_id repository:tag# -a 表示 attach, -i 表示 iterativedocker start -a -i container_id# -f 表示 forcedocker stopdocker kill -f 参考资料","tags":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/tags/技术开发/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"Docker","slug":"技术开发/Docker","permalink":"http://yoursite.com/categories/技术开发/Docker/"}]},{"title":"Make Life Easier","date":"2019-01-03T02:22:30.000Z","path":"wiki/某些Tricks/Make-Life-Easier/","text":"我现在发现, 为什么不用 Docker …是的, 赶紧把 Docker 用熟来. 装好 Docker 和 Nvidia-docker, 然后使用 sshfs 将远程服务器的文件映射到本地, 嗯, 真香~ Docker Documentation NVIDIA-docker Documentation 安装 oh-my-zsh可供参考的资料: https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH https://www.howtoforge.com/tutorial/how-to-setup-zsh-and-oh-my-zsh-on-linux/ 在 Ubuntu 上, 使用: 12345678sudo apt-get install zshchsh -s $(which zsh) # make your default shellexport SHELL=/bin/zsh # if the above command has no effectexec $SHELLsudo apt-get install wget gitwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrcsource ~/.zshrc 安装插件Become A Command-Line Power User With Oh My ZSH And Z 在 ~/.zshrc 中修改 plugins 那一行: 1plugins=(git vi-mode z) 要使用 z 的话, 需要先下载 z.sh 123wget https://github.com/rupa/z/blob/master/z.shmv z.sh ~/.zexec $SHELL 上面这种安装方法我认为是最简单的了, 另外还有一种方法可以参考: Boost Productivity with Z and Zsh on Ubuntu Pyenv 管理多版本的 Python 安装 Pyenv 主页在: https://github.com/pyenv/pyenv, Mac 用户可以使用 Homebrew 安装, 此时安装的路径在: 1/usr/local/Cellar/pyenv 而 Ubuntu 用户可以使用如下一些命令安装 (先把 oh-my-zsh 装好) 12345git clone https://github.com/pyenv/pyenv.git ~/.pyenvecho 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.zshrcecho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.zshrcecho -e 'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\\n eval \"$(pyenv init -)\"\\nfi' &gt;&gt; ~/.zshrcexec $SHELL 加快 Python/Anaconda 的下载速度 要使各个版本的发行版加快下载, 可以修改为清华镜像, 比如我的 anaconda3-4.2.0 文件如下, 其中 https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 是重点, 还有后面一大堆估计是编码的东西也给删掉了. 首先到 Pyenv 的如下目录: 123pyenv_root='~/.pyenv' # Ubuntupyenv_root=/usr/local/Cellar/pyenv # Mac$(pyenv_root)/1.2.7/plugins/python-build/share/python-build 然后修改 anaconda3-4.2.0 文件, 这里给的例子是修改 OSX 系统的: 1234567891011121314151617181920case \"$(anaconda_architecture 2&gt;/dev/null || true)\" in\"Linux-x86\" ) install_script \"Anaconda3-4.2.0-Linux-x86\" \"https://repo.continuum.io/archive/Anaconda3-4.2.0-Linux-x86.sh#1a8320635f2f06ec9d8610e77d6d0f9cb2c5d11d20a4ff7fcda113e04b0a8a50\" \"anaconda\" verify_py35 ;;\"Linux-x86_64\" ) install_script \"Anaconda3-4.2.0-Linux-x86_64\" \"https://repo.continuum.io/archive/Anaconda3-4.2.0-Linux-x86_64.sh#73b51715a12b6382dd4df3dd1905b531bd6792d4aa7273b2377a0436d45f0e78\" \"anaconda\" verify_py35 ;;\"MacOSX-x86_64\" ) #install_script \"Anaconda3-4.2.0-MacOSX-x86_64\" \"https://repo.continuum.io/archive/Anaconda3-4.2.0-MacOSX-x86_64.sh#95448921601e1952e01a17ba9767cd3621c154af7fc52dd6b7f57d462155a358\" \"anaconda\" verify_py35 install_script \"Anaconda3-4.2.0-MacOSX-x86_64\" \"https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-4.2.0-MacOSX-x86_64.sh\" \"anaconda\" verify_py35 ;;* ) &#123; echo colorize 1 \"ERROR\" echo \": The binary distribution of Anaconda3 is not available for $(anaconda_architecture 2&gt;/dev/null || true).\" echo &#125; &gt;&amp;2 exit 1 ;;esac 修改 Pip 的镜像修改 ~/.pip/pip.conf 文件如下: 12345[global]index-url=http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com conda 设置清华镜像Anaconda | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror 123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes tmux 相关 tmux 搜索不到配置文件的处理方法 根据 https://unix.stackexchange.com/questions/66606/tmux-not-sourcing-my-tmux-conf 的介绍, 如果 tmux 搜索不到 .tmux.conf 配置文件, 那么可以先使用默认的快捷键 Ctrl+B, 然后输入 : 冒号, 类似于 vim 的命令模式, 再输入命令 source-file ~/.tmux.conf 参考资料","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"工具性网站总结","date":"2018-12-16T14:32:34.000Z","path":"wiki/网络资源/工具性网站总结/","text":"https://sm.ms/ 好用的图床, 我目前 Wiki 的图像都是上传到这个网站上, 但是图像大小有限制, 5Mb 以内. https://www.soogif.com/compress Gif 图像压缩, 这个压缩力度感觉很猛… https://www.iloveimg.com/zh-cn/compress-image 图像压缩, 也很不错, 和上面那个结合使用 免费图床总结 参考资料","tags":[{"name":"Resource","slug":"Resource","permalink":"http://yoursite.com/tags/Resource/"}],"categories":[{"name":"网络资源","slug":"网络资源","permalink":"http://yoursite.com/categories/网络资源/"}]},{"title":"Hexo引用站内文章","date":"2018-12-16T13:08:02.000Z","path":"wiki/某些Tricks/Hexo引用站内文章/","text":"在写博客的过程中需要引用自己写的文章, 根据下面的参考资料 1 中所述, 可以使用内置的标签插件的语法 post_link 来实现引用, 具体的语法是: 12&#123;% post_link 文章文件名(不要后缀) 文章标题(可选) %&#125;# &#123;% post_link slug [title] %&#125; 其中 slug 就是 _posts 文件夹下需要引用的文章的 markdown 文件的名字，title 可以指定引用的文章需要显示的名字. 举个例子, 我的 Wiki 中 程序语言-&gt;Python-&gt;实用程序-&gt;查找相似图片 这篇文章中, 需要引用我的另外两篇文章, 相关写法如下: 12+ &#123;% post_link 程序语言/Python/实用程序/Matplotlib响应按键浏览图片 %&#125;+ &#123;% post_link 程序语言/Python/实用程序/Logger用于log记录 %&#125; 因为这两篇文章都在 source/_posts/程序语言/Python/实用程序/ 目录下. 参考资料 Hexo博客搭建之引用站内文章 Hexo引用站内文章","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"查找相似图片","date":"2018-12-16T12:19:01.000Z","path":"wiki/程序语言/Python/实用程序/查找相似图片/","text":"找相似图片的原理主要有颜色直方图, 感知哈希算法等, 详情可以看参考资料中阮一峰的博客, 相当之详细. 先看看效果吧: ImageSimilarity 实现要运行该代码, 对于 python 库, 主要需要安装 pillow 以及 tqdm. 另外, 还需要我写的 ImageViewer.py 以及 Logger.py 文件, 它们分别可以在如下位置找到: Matplotlib响应按键浏览图片 Logger用于log记录 下面实现的 Finder 对象中的 find_all 方法, 传入要搜寻的目录, 从该目录中找到和目标图像相似的图像. 如果在运行程序时, 设置 --show True, 那么可以使用 ImageViewer 提供的功能, 方便的通过快捷键浏览图像. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import argparseimport globimport osimport sysimport numpy as npfrom os.path import join, existsfrom functools import reducefrom datetime import datetimeimport matplotlib.pyplot as pltfrom PIL import Imagefrom tqdm import tqdmfrom ImageViewer import ImageViewerfrom Logger import InfoLogger, args_namespaceparser = argparse.ArgumentParser('Find Similar Images')parser.add_argument('--log_checkpoint', type=str, default='./infologger', help=\"log files savepath\")parser.add_argument('--log_file', type=str, default=\"&#123;:%Y-%m-%d-%H:%M:%S&#125;.log\".format(datetime.now()), help='logfile name')parser.add_argument('--image', type=str, default=\"./Set14/monarch.png\", help='base image name')parser.add_argument('--search', type=str, default=\"./bsd100\", help='which dir to search similar images')parser.add_argument('--rank', type=int, default=10, help='how many similar images to search')parser.add_argument('--method', type=str, default='color_hist', help='similar image algorithm, &#123;color_hist | avhash&#125;')parser.add_argument('--show', type=str, default='False', help='whether show similar images or not')parser.add_argument('--savepath', type=str, default='./ResultImgs', help='path to save base image and similar_imgs')opt = parser.parse_args()logger = InfoLogger(opt)logger.info(args_namespace(opt))class Finder(object): def __init__(self, img_path): self.base_img = img_path self.similar_imgs = [] def find_indir(self, img_dir, rank=20, method='color_hist'): \"\"\"method = &#123;'color_hist' | 'avhash'&#125;\"\"\" logger.info('Find similar image of: &#123;&#125;'.format(self.base_img)) logger.info('Searching directory: &#123;&#125;'.format(img_dir)) seq = [] if method == 'avhash': base_h = self.avhash(self.base_img) for filename in tqdm(os.listdir(img_dir)): fullname = join(img_dir, filename) seq.append((fullname, self.hamming(self.avhash(fullname), base_h))) elif method == 'color_hist': for filename in tqdm(os.listdir(img_dir)): fullname = join(img_dir, filename) seq.append((fullname, -1 * self.color_hist(self.base_img, fullname, mode=2))) for idx, (f, ham) in enumerate(sorted(seq, key=lambda i: i[1])): if idx &gt;= rank: break logger.info(\"&#123;&#125;\\t&#123;&#125;\".format(ham, f)) self.similar_imgs.append(f) def show_similar_imgs(self): im = np.array(Image.open(self.base_img).convert('RGB')) fig, ax = plt.subplots() ax.imshow(im) ax.set_title('Base Image') viewer = ImageViewer(self.similar_imgs) viewer.fig.suptitle('Similar Images') viewer.show() # https://blog.csdn.net/birdy_/article/details/78822901 # https://blog.csdn.net/Mengwei_Ren/article/details/73359298 # base on color histogram def difference(self, hist1, hist2): sum1 = 0 for i in range(len(hist1)): if (hist1[i] == hist2[i]): sum1 += 1 else: sum1 += 1 - float(abs(hist1[i] - hist2[i])) / max(hist1[i], hist2[i]) return sum1/len(hist1) def color_hist(self, path1 , path2 , mode=2): if(mode == 3): img1 = Image.open(path1).resize((8,8)).convert('1') img2 = Image.open(path2).resize((8,8)).convert('1') hist1 = list(img1.getdata()) hist2 = list(img2.getdata()) return self.difference(hist1, hist2) # preprocess img1 = Image.open(path1).resize((256,256)).convert('RGB') img2 = Image.open(path2).resize((256,256)).convert('RGB') if(mode == 1): return self.difference(img1.histogram(), img2.histogram()) if(mode == 2): sum = 0 for i in range(4): for j in range(4): hist1 = img1.crop((i*64, j*64, i*64+63, j*64+63)).copy().histogram() hist2 = img2.crop((i*64, j*64, i*64+63, j*64+63)).copy().histogram() sum += self.difference(hist1, hist2) return sum/16 # http://www.ruanyifeng.com/blog/2011/07/principle_of_similar_image_search.html # base on Perceptual hash algorithm def avhash(self, im): if not isinstance(im, Image.Image): im = Image.open(im) im = im.resize((8, 8), Image.ANTIALIAS).convert('L') avg = reduce(lambda x, y: x + y, im.getdata()) / 64. return reduce(lambda x, yz: x | (yz[1] &lt;&lt; yz[0]), \\ enumerate(map(lambda i: 0 if i &lt; avg else 1, im.getdata())), \\ 0) def hamming(self, h1, h2): h, d = 0, h1 ^ h2 while d: h += 1 d &amp;= d - 1 return hif __name__ == '__main__': finder = Finder(opt.image) finder.find_indir(opt.search, rank=opt.rank, method=opt.method) if opt.show == 'True': finder.show_similar_imgs() 参考资料 相似图片搜索的原理 相似图片搜索的原理（二） 【python + PIL】图像相似度检测 【图像处理】图像检索的三种python实现(直方图/OpenCV/哈希法)","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://yoursite.com/tags/Matplotlib/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"实用程序","slug":"程序语言/Python/实用程序","permalink":"http://yoursite.com/categories/程序语言/Python/实用程序/"}]},{"title":"Logger用于log记录","date":"2018-12-16T11:11:57.000Z","path":"wiki/程序语言/Python/实用程序/Logger用于log记录/","text":"写程序进行日志记录真的非常方便, 这里提供 InfoLogger 类, 用于对日志的记录. 比如: 12logger = InfoLogger(opt=None)logger.info('Hello World') 默认创建 log/ 文件夹并在该文件夹中记录日志, 如果要修改目录, 那么就要传入 opt 对象, 该对象需要分别指定 opt.log_checkpoint 属性说明日志存放的目录, 以及 opt.log_file 属性: log 文件的名字. 另外还提供 args_namespace 函数, 用于处理 argparse.Namespace 对象 (即 opt = parser.parse_args()). 具体效果看下面的内容. 关于 opt 对象, 有 log_checkpoint 或 log_file 就行, 没有这两个属性就采用默认值. 1234567parser = argparse.ArgumentParser('Logger')parser.add_argument('--log_checkpoint', type=str, default='log/', help='log directory')opt = parser.parse_args()# oropt = type('Option', (object,), &#123;&#125;)opt.log_checkpoint = 'log/' InfoLogger 类的实现Logger.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import loggingfrom datetime import datetimefrom pprint import pprint as ppfrom os.path import exists, joinimport osdef args_namespace(opt): res = [\"&#123;&#125;: &#123;&#125;\\n\".format(attr, getattr(opt, attr)) for attr in vars(opt)] return \"Argument Settings:\\n\" + \\ \"===============================================================\\n\" + \\ \"\".join(res) + \\ \"===============================================================\"class InfoLogger(object): def __init__(self, opt=None): super(InfoLogger, self).__init__() if not getattr(opt, 'log_checkpoint', None): log_checkpoint = 'log' else: log_checkpoint = opt.log_checkpoint if not getattr(opt, 'log_file', None): log_file = \"&#123;:%Y-%m-%d-%H:%M:%S&#125;.log\".format(datetime.now()) else: log_file = opt.log_file if not exists(log_checkpoint): os.makedirs(log_checkpoint) logging.basicConfig(level=logging.INFO) self.logger = logging.getLogger('main') handler = logging.FileHandler(join(log_checkpoint, log_file), mode='w') handler.setLevel(logging.INFO) formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S') handler.setFormatter(formatter) self.logger.addHandler(handler) def __getattr__(self, item): return self.logger.__getattribute__(item)if __name__ == '__main__': # you can also use argparse, I use `type` here just for convenience. opt = type('Option', (object, ), &#123;&#125;) opt.log_checkpoint = './infologger' opt.log_file = 'test.log' logger = InfoLogger(opt) logger.info(args_namespace(opt)) logger.info('hello world') demo 效果如下: 参考资料","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"实用程序","slug":"程序语言/Python/实用程序","permalink":"http://yoursite.com/categories/程序语言/Python/实用程序/"}]},{"title":"Matplotlib响应按键浏览图片","date":"2018-12-16T11:10:40.000Z","path":"wiki/程序语言/Python/实用程序/Matplotlib响应按键浏览图片/","text":"最近写了一个查找相似图像的算法, 目标是给定 A 图片, 然后在目录 B/ 中查找和 A 图片相似的图片. 假设在 B/ 中我找到了 10 张相似图片, 但是要查看这 10 张图, 在 Mac 上我先到文件夹下, 然后使用 preview 进行查看, 有点麻烦, 我想是否可以用 matplotlib 显示这些图片, 然后按下 n 就浏览下一张, 按下 N 浏览上一张. 于是就有了下面的脚本, 同时复习一下 Matplotlib 的事件处理代码如何写. ImageViewer 类的实现ImageViewer 类的具体实现如下, img_list 是包含图像绝对路径的 list. 代码最后给了 demo, 很简单. demo 中的效果是浏览一个文件夹中的图片, 按 n 访问下一张, 按 N 访问上一张. ImageViewer.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import numpy as npfrom PIL import Imageimport matplotlibimport matplotlib.pyplot as pltclass ImageViewer(object): def __init__(self, img_list): self.img_list = list(img_list) self.fig, self.ax = plt.subplots() self.num_of_img = len(self.img_list) self.indicator = 0 self.connect() def path2array(self, img_path): im = Image.open(img_path).convert('RGB') im = np.array(im) return im def show(self): if self.img_list: im = self.path2array(self.img_list[self.indicator]) self.ax.imshow(im) plt.show() def connect(self): self.cidkey = self.fig.canvas.mpl_connect( 'key_press_event', self.on_keypress) def on_keypress(self, event): if self.img_list: if event.key in ['n']: self.indicator += 1 elif event.key in ['N']: self.indicator -= 1 # dont worry about negative self.indicator, % will automatically handle it self.indicator = self.indicator % self.num_of_img im = self.path2array(self.img_list[self.indicator]) self.ax.imshow(im) self.fig.canvas.draw()if __name__ == '__main__': import os from os.path import join, exists img_dir = './bsd100' img_list = [join(img_dir, name) for name in os.listdir(img_dir)] viewer = ImageViewer(img_list) viewer.show() 按键响应Matplotlib 提供 key_press_event, 回调函数为 self.on_keypress. 在该函数中, 使用 self.indicator 记录当前指向第几张图片 (从 0 开始计数). 为了循环访问的效果, 使用求余符号 % 控制 self.indicator 的变化. 1234567891011121314151617def connect(self): self.cidkey = self.fig.canvas.mpl_connect( 'key_press_event', self.on_keypress)def on_keypress(self, event): if self.img_list: if event.key in ['n']: self.indicator += 1 elif event.key in ['N']: self.indicator -= 1 # dont worry about negative self.indicator, % will automatically handle it self.indicator = self.indicator % self.num_of_img im = self.path2array(self.img_list[self.indicator]) self.ax.imshow(im) self.fig.canvas.draw() 参考资料","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://yoursite.com/tags/Matplotlib/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"实用程序","slug":"程序语言/Python/实用程序","permalink":"http://yoursite.com/categories/程序语言/Python/实用程序/"}]},{"title":"有意思的Github项目","date":"2018-11-28T15:08:11.000Z","path":"wiki/网络资源/有意思的Github项目/","text":"机器学习 机器学习路线图 资料很全, 可以参考 Git 相关 An interactive git visualization to challenge and educate! 将 Git 的操作可视化, 我觉得之后对于 Git 的学习会很有帮助! Visualizing Git 可视化 Git, 真的好用啊, 对概念体会更深 科研GAN Pytorch-based tools for visualizing and understanding the neurons of a GAN. 现在 GAN 的发展简直太快了… 参考资料","tags":[{"name":"Resource","slug":"Resource","permalink":"http://yoursite.com/tags/Resource/"}],"categories":[{"name":"网络资源","slug":"网络资源","permalink":"http://yoursite.com/categories/网络资源/"}]},{"title":"DetailViewer简要介绍","date":"2018-11-27T06:56:46.000Z","path":"wiki/程序语言/Python/Matplotlib/DetailViewer简要介绍/","text":"DetailViewer 简要介绍DetaiViewer 是用来放大图像细节的工具, 它意在帮助从事底层图像处理的科研人员方便对比各种算法的效果. 比如在图像去噪, 图像超分辨率的论文中, 我们常常需要将自己的算法和其他的 state-of-the-art 的算法进行视觉效果上的比较, DetailViewer 就是为了方便这一过程, 效果如下图: 下面介绍使用 Python 和 Matplotlib 实现 DetailViewer 的过程. DetailViewer 包含两个主要的 API: FigureInfo class RectangleSelection class 其中最为重要的是 RectangleSelection 这个类了, 你可以直接将一个 matplotlib.figure.Figure 对象传入到这个类中, 然后就可以利用其中的画出正方形以及移动正方形并动态显示图像细节等功能. 而 FigureInfo 只是根据你传入的图像大小和数量简单设置这些图像的布局, 这部分内容其实你自己也可以写. 下面首先重点说一下 RectangleSelection 的实现. 在详细说明细节之前, 先介绍一下我的编程环境: 12345Anaconda Python 3.5.6Matplotlib 3.0.0 # 注意 Matplotlib 的版本至少是 3.0.0, 因为会用到 matplotlib.axes.Axes 对象的 inset_axes 方法.Numpy 1.14.2PIL (pillow) 5.1.0scikit-image 0.14.0 面向对象 API首先需要认识 Matplotlib 中的 Artist, 关于这一点, 可以详细学习 Matplotlib Artist Tutorial, Artists 主要有两种类型: primitives 和 containers. 像 Line2D, Rectangle, Text, AxesImage 等都属于 primitives, 而 Axes 和 Subplots 就属于 containers. 明确 Artists 的概念后, 再来理解一下 Axes 和 Subplots 的关系, 比如对于如下代码: 1fig, ax = plt.subplots() 它返回两个对象: matplotlib.figure.Figure 以及 matplotlib.axes.Axes, 上面那句代码相当于如下: 12345fig = plt.figure()ax = fig.add_subplot(111)# 和下面的代码还是有一些差异的, 但是本质上是类似的ax = fig.add_axes([0., 0., 1., 1.]) 另外需要注意的是 plt.subplots() 会返回一个 Axes 对象或者一个 Numpy 数组, 比如: 12345678910111213141516&gt;&gt;&gt; fig, ax = plt.subplots()&gt;&gt;&gt; print(ax)AxesSubplot(0.125,0.11;0.775x0.77)&gt;&gt;&gt; fig, axes = plt.subplots(2, 2)&gt;&gt;&gt; print(repr(axes))array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x11537a160&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x115392748&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1153a9cc0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x11744b278&gt;]], dtype=object)&gt;&gt;&gt; print(axes.shape)(2, 2)# 由于这里 axes 的 shape 是 (2, 2), 那么之后为了用 for 循环方便访问每个 ax, 可以使用:# for ax in axes.ravel() (或者使用 axes.flat) 所以在代码中, 为了处理的统一性, 我会对 ax 使用 ax = np.array(ax) 进行转换, 方便处理, 防止用户只传入一张图片. Matplotlib 中的事件处理和 pickingMatplotlib 提供如下事件处理, 更为详细的信息请查看: https://matplotlib.org/users/event_handling.html 在 DetailViewer 中的 RectangleSeletion 类中, 事件处理使用 connect 方法完成: 1234567891011def connect(self): self.cidpress = self.fig.canvas.mpl_connect( 'button_press_event', self.on_press) self.cidmotion = self.fig.canvas.mpl_connect( 'motion_notify_event', self.on_motion) self.cidpick = self.fig.canvas.mpl_connect( 'pick_event', self.on_pick) self.cidrelease = self.fig.canvas.mpl_connect( 'button_release_event', self.on_release) self.cidkey = self.fig.canvas.mpl_connect( 'key_press_event', self.on_keypress) 从上至下依次是: 鼠标按下事件: 确认鼠标的位置, 判断鼠标是否在某个 Axes 中; 只允许画一个矩形; 鼠标移动事件: 确认鼠标位置; 确认用户有画矩形的意图; 用户画出矩形; 用户移动矩形的处理方式; 矩形移动事件: 用户如果移动矩形, 各种状态的变化; 鼠标释放事件: 各种状态的变化; 如果用户画出了矩形, 那么要放大图像; 按键响应事件: 针对用户按下键盘上的按键, 做出相应的响应. 每个事件要跟一个操作进行联系, 需要使用 FigureCanvasBase.mpl_connect 方法, 比如 self.fig.canvas.mpl_connect 方法, 该方法返回一个事件 connection id, 简称 cid, 之后可以用于 mpl_disconnect 方法. 下面依次介绍各个事件. 状态变量12345678910class RectangleSelection(object): def __init__(self, fig): self.fig = fig # 画板 self.cur_axes = None # 鼠标当前所在的 axes self.rect = None # 用户画出的矩形 self.x0, self.y0 = None, None # 矩形的左上角坐标 self.x1, self.y1 = None, None # 矩形的右下角坐标 self.is_picking = False # 用户是否选中了矩形 self.sub_axes = list() # 保存图像上所有的轴域 self.connect() # 将事件与 handling 进行关联 鼠标按下事件:12 参考资料 Matplotlib User’s Guide: Interactive plots","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://yoursite.com/tags/Matplotlib/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"Matplotlib","slug":"程序语言/Python/Matplotlib","permalink":"http://yoursite.com/categories/程序语言/Python/Matplotlib/"}]},{"title":"Ubuntu软件安装","date":"2018-11-27T06:36:45.000Z","path":"wiki/技术开发/Unix/Ubuntu/Ubuntu软件安装/","text":"Ubuntu 安装 gcc-4.9参考: Getting + installing gcc/g++ 4.9 on Ubuntu? 1234567891011sudo su -apt-get install build-essentialadd-apt-repository ppa:ubuntu-toolchain-r/testapt-get updateapt-get install gcc-4.9 g++-4.9 cpp-4.9cd /usr/binrm gcc g++ cppln -s gcc-4.9 gccln -s g++-4.9 g++ln -s cpp-4.9 cpp 除了使用软连接, 还可以使用 update-alternatives 来修改 gcc 默认的版本, 具体可以参考上面的参考资料. systemctl: command not found参考: systemctl: command not found on ubuntu 16.04 1234sudo apt-get install systemd# 如果软件损坏, 重装的方法sudo apt-get reinstall systemd frpc 设置开机自启动参考: Github: frp怎样开机启动和后台运行? 在 /etc/systemd/system/ 中添加 frpc.service 文件, 内容如下: 1234567891011121314[Unit]Description=frpc daemonAfter=syslog.target network.targetWants=network.target[Service]Type=simpleExecStart=/home/ieric/Programs/frp_0.20.0_linux_amd64/frpc -c /home/ieric/Programs/frp_0.20.0_linux_amd64/frpc.iniRestart= alwaysRestartSec=1minExecStop=/usr/bin/killall frpc[Install]WantedBy=multi-user.target 再修改一下 mode, sudo chmod a+x frpc.service. 在 frpc.ini 配置文件中设置 login_fail_exit 的值为 false (默认是 true), 这样的话, 当启动时没有连上服务器就不会立即退出, 而是每隔 30s 自动重连. 完成以上两步之后, 使用 1234567sudo systemctl enable frpcsudo systemctl status frpc# 这是输出状态frpc.service - frpc daemon Loaded: loaded (/etc/systemd/system/frpc.service; enabled) Active: inactive .... 重启与关机12sudo reboot -nfsudo shutdown now 参考资料","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"Unix","slug":"技术开发/Unix","permalink":"http://yoursite.com/categories/技术开发/Unix/"},{"name":"Ubuntu","slug":"技术开发/Unix/Ubuntu","permalink":"http://yoursite.com/categories/技术开发/Unix/Ubuntu/"}]},{"title":"编程资源汇总","date":"2018-11-26T15:25:18.000Z","path":"wiki/网络资源/编程资源汇总/","text":"编程资源总结 Github: 免费的编程中文书籍索引 简书: 程序员书籍汇总下载 Github: python中文库-python人工智能大数据自动化接口测试开发 Github: Machine Learning for OpenCV PyTorch Cookbook (常用代码段整理合集) 使用 Matplotlib 绘制高质量的图片 参考资料","tags":[{"name":"Resource","slug":"Resource","permalink":"http://yoursite.com/tags/Resource/"}],"categories":[{"name":"网络资源","slug":"网络资源","permalink":"http://yoursite.com/categories/网络资源/"}]},{"title":"vim技巧","date":"2018-11-26T15:11:51.000Z","path":"wiki/技术开发/Unix/Vim/vim技巧/","text":"调整窗口的高度和宽度参考博客 1. 其中使用 c-w, &gt; 和 c-w, &lt; 最为方便. 12345678910111213141516171819CTRL-W = 使得所有窗口 (几乎) 等宽、等高，但当前窗口使用 'winheight' 和 'winwidth'。:res[ize] -N CTRL-W - 使得当前窗口高度减 N (默认值是 1)。如果在 'vertical' 之后使用，则使得宽度减 N。:res[ize] +N CTRL-W + 使得当前窗口高度加 N (默认值是 1)。如果在 'vertical' 之后使用，则使得宽度加 N。:res[ize] [N]CTRL-W CTRL-_ CTRL-W _ 设置当前窗口的高度为 N (默认值为最大可能高度)。:vertical res[ize] [N] CTRL-W | 设置当前窗口的宽度为 N (默认值为最大可能宽度)。z&#123;nr&#125;&lt;CR&gt; 设置当前窗口的高度为 &#123;nr&#125;。 CTRL-W &lt; 使得当前窗口宽度减 N (默认值是 1)。 CTRL-W &gt; 使得当前窗口宽度加 N (默认值是 1)。 参考资料 vim: vs sp 调整窗口高度和宽度","tags":[{"name":"Unix","slug":"Unix","permalink":"http://yoursite.com/tags/Unix/"},{"name":"Vim","slug":"Vim","permalink":"http://yoursite.com/tags/Vim/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"Unix","slug":"技术开发/Unix","permalink":"http://yoursite.com/categories/技术开发/Unix/"},{"name":"Vim","slug":"技术开发/Unix/Vim","permalink":"http://yoursite.com/categories/技术开发/Unix/Vim/"}]},{"title":"稀疏表示去噪","date":"2018-11-26T14:00:14.000Z","path":"wiki/专业研究/稀疏表示去噪/","text":"稀疏表示能去噪的原因下面的论述来自参考博客一. 可以认为含噪（观测）图像是由无噪（原始）图像和噪声合成的图像，而观测图像被认为是可稀疏的，即可以通过有限个原子来表示，而噪声是随机的不可稀疏的，即不可以通过有限个原子表示，因此通过观测图像去提取图像的系数成分，再用这些稀疏成分来重构图像，在这个过程中，噪声被处理为观测图像和重构图像之间的残差，在重构过程中残差被丢弃，从而达到去噪的效果。稀疏表示又称为稀疏编码，这个过程可以被视为特征提取的过程，可以看作把目标信号投影到一组非正交的基构成的空间中，而在每个基上投影的系数，就是稀疏编码。这组非正交的基向量中，每一个基向量被称为一个原子，这些原子（列向量）可以构成一个超完备的字典。那么，为什么要使用过完备的字典，或者说要在非正交的空间进行投影呢？对于一组正交基而言，它们可以准确而唯一地表示空间中的任何向量，而且这些向量间没有冗余（因为正交），正式因为严格的正交限制，因此正交基的展开简单，但是稀疏性不够理想，因为严格正交的基往往只能表示图像的某一个特征而不能够同时表示其他特征，因此正交基的稀疏性不及非正交基(过完备字典). 参考资料 稀疏表示去噪的理解","tags":[{"name":"专业研究","slug":"专业研究","permalink":"http://yoursite.com/tags/专业研究/"}],"categories":[{"name":"专业研究","slug":"专业研究","permalink":"http://yoursite.com/categories/专业研究/"}]},{"title":"Git多用户","date":"2018-11-25T15:29:18.000Z","path":"wiki/某些Tricks/Git多用户/","text":"设置 SSH使用 ssh-keygen 产生新的秘钥, 然后将 .pub 放到 Github 上. 之后修改 .ssh/config 文件, 设置 1234Host xzml HostName github.com User git IdentityFile ~/.ssh/id_rsa_xzml 最后使用 ssh -T xzml 对 Github 进行访问, 如果成功的话, 会返回: 1Hi xzml! You've successfully authenticated, but GitHub does not provide shell access. 参考资料","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"Mac下使用Hexo+Github搭建个人博客","date":"2018-11-25T14:58:43.000Z","path":"wiki/某些Tricks/Mac下使用Hexo-Github搭建个人博客/","text":"准备工作建议看看参考博客中的第一个, 图文并茂, 可以感受到很多细节, 作者非常用心, 第二个参考博客是更新奇的内容, 包括插入图片, 购买域名等. 安装 Nodejs 和 npmHexo 是用 Nodejs 写成了, 所以需要先安装 Nodejs 和 npm, 推荐使用 Homebrew 安装. 安装完 Nodejs 后建议设置 npm 淘宝镜像. 1234567brew install nodenpm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global# 查看版本号node -vnpm -v 安装 Hexo1234npm install -g hexo# 查看版本号hexo -v 本地调试创建某个目录用于存放你的博客, 比如我创建了 PWiki/ 文件夹用于存放博客相关的文件, 然后执行如下命令: 123456hexo init # 首先初始化 Hexo, 会将相关的文件从 Github 上下载下来, 默认使用 landscape 主题npm install # 在部署博客之前需要安装依赖项, 我想这个命令会直接读取 PWiki/package.json 文件中的内容hexo generate # 生成静态页面, Hexo 是一个博客框架, 只有执行了 generate 命令才能生成具体的 html, css 等文件hexo server # 启动服务, 用于本地调试hexo clean # 可以清除已经产生的静态页面, 如 PWiki/publish 目录hexo new # 创建新博客 本地打开 http://localhost:4000 进行效果查看 命令缩写: 123hexo generate # 缩写 hexo ghexo server # 缩写 hexo shexo new # 缩写 hexo n 部署到 Github 首先在 Github 上创建名为 &lt;user&gt;.github.io 的 repository, 我的 &lt;user&gt; 就是 xzml. 然后在 PWiki/_config.yml 文件的 deploy 项下, 增加如下内容: 1234deploy: type: git repository: git@github.com:xzml/xzml.github.io.git branch: master 安装 Github 部署器: 1npm install hexo-deployer-git --save 否则应该会出现 ERROR Deployer not found: git 错误. 将静态博客部署到 Github 上: 1hexo deploy # 缩写 hexo d 更换主题按照 https://github.com/zthxxx/hexo-theme-Wikitten 中的 README.md 操作就可以了. 大致思路就是: 从 Github 上将主题下载到 PWiki/ 下的 themes 目录下 修改 PWiki/themes/Wikitten/_config.yml 文件, 对主题进行配置 修改 PWiki/_config.yml 文件, 对项目进行配置, 比如将 theme 这一项更改为 Wikitten. 另外需要注意的是 Wikitten 主题需要额外的一些插件, README.md 中写了, 为了安装它们, 我在 PWiki/package.json 直接增加了如下部分: 1234567891011121314151617\"dependencies\": &#123; \"hexo\": \"^3.7.0\", \"hexo-autonofollow\": \"^1.0.1\", \"hexo-deployer-git\": \"^0.3.1\", \"hexo-directory-category\": \"^1.0.5\", \"hexo-generator-archive\": \"^0.1.5\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-feed\": \"^1.2.2\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-json-content\": \"^3.0.1\", \"hexo-generator-sitemap\": \"^1.2.0\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.3.1\", \"hexo-renderer-marked\": \"^0.3.2\", \"hexo-renderer-stylus\": \"^0.3.3\", \"hexo-server\": \"^0.3.1\"&#125; 然后再使用 npm install 命令安装即可. 还有要注意修改主题的 _config.yml 文件, 将原作者的个人信息改成自己的信息. 保存博客到仓库我们自己使用 hexo new &lt;title&gt; 产生的博客源文件一般是放在 PWiki/source/_posts/ 目录下, 使用 hexo generate 命令产生的静态页面一般是放在 PWiki/publish/ 文件夹下. 为了对博客的 Markdown 源文件以及博客使用的主题进行备份, 参考 Wikitten 原作者的方法, 我在 Github 上创建了一个名为 Wiki-site 的仓库用于存储这些源文件. 具体方法是: 在 Github 上创建一个名为 Wiki-site 的新仓库; 在本地上的 PWiki/ 目录下使用 git init 命令; 修改 PWiki/ 项目中的 .gitignore 文件, 过滤掉那些不需要追踪版本的文件; 另外要注意的问题是, 由于 PWiki/themes/Wikitten 是个 git submodule, 在 PWiki/ 目录下直接使用 git add * 之类的命令可能会引起一些 Warning, 我的做法是到 PWiki/themes/Wikitten/ 目录下先用 git add/commit 等命令处理好后, 再回到 PWiki/ 目录使用 git add/commit 命令; 回到 PWiki/ 目录, 将上面的修改都 git add/commit; 将本地项目与远程服务器进行关联, git remote add origin git@github.com:xzml/Wiki-site.git (具体可以参考第 5 个博客) 执行 git pull origin master, 将远程服务器中的 master 分支和本地的 origin 合并, 防止冲突. 上面没有报错之后, 可以使用 git status 查看当前本地仓库是不是干净的, 如果是的话, 就可以使用 git push -u origin master 推送到 Github 上了. 上面的步骤其实已经将问题给搞定了, 这里记录一个我出现的问题: 我有多个 Github 账号, 即使设置了 PWiki/ 的 local user 为 xzml, 在使用 git push -u origin master 时, 仍会使用另一个 userb. 由于我访问 Github 使用的是 SSH, 这说明访问 `git@github.com时使用的是 userb, 为了使通过 SSH 访问git@github.com使用 xzml, 我直接修改PWiki/.git/config文件中的url = xzml:xzml/Wiki-site.git, 这是因为我在.ssh/config给通过 xzml 访问git@github.com这一行为设置了别名为xzml`. 参考资料 Mac 下 Hexo 和 GitHub-Pages 搭建个人博客（一） Mac 下 Hexo 和 GitHub-Pages 搭建个人博客（二） macOS环境下利用Github和Hexo部署博客 使用 Hexo 生成静态博客过程记录 使用Git命令把本地项目上传到Github托管","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"关于Wiki的主题","date":"2018-11-25T14:35:41.000Z","path":"wiki/某些Tricks/关于Wiki的主题/","text":"不可思议的 Tricks比如使用 Markdown 中的列表, 像如下代码是不会显示列表前面的点 $\\bullet$: 1+ `a` 是一个数组 效果如下: a 是一个数组 需要写成: 1+ 参数 `a` 是一个数组. 才能得到想要的效果: 参数 a 是一个数组. 修改 Wikitten 模板的属性修改字体可以去 themes/Wikitten/source/css 目录下, 查看 style.styl 文件, 发现其中还会导入 _variables.styl 文件, 只需要修改该文件中的相关属性即可. 修改代码使用的主题当前我使用的代码主题 (配色) 是 solarized-light, 要查看其它的配色, 可以看 themes/Wikitten/source/css/_highlight 目录, 里面有大量的配色文件, 这些文件的文件名就是某种主题, 只需要将文件名填入 themes/Wikitten/_config.yml 中的 highlight 项目下即可. 比如: 1highlight: solarized-dark # monakai 参考资料参考资料中有 Wikitten 主题的地址, 以及原作者写的关于使用 Hexo 搭建个人 Wiki 的博客. 使用 Hexo 做个人 Wiki 知识管理系统 作者的个人 Wiki 地址 Wikitten 主题地址","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"numpy中的random函数","date":"2018-11-25T11:41:45.000Z","path":"wiki/程序语言/Python/Numpy/numpy中的random函数/","text":"Random Datanp.random.rand1np.random.rand(d0, d1, ..., dn) rand 函数根据给定的维度产生 $[0, 1)$ 之间的随机数, 服从均匀分布 (uniform distribution) np.random.randn1np.random.randn(d0, d1, ..., dn) randn 函数返回服从标准正态分布 ($\\mathcal{N}(0, 1)$) 的随机数, 要返回服从 $\\mathcal{N}(\\mu, \\sigma)$ 的样本, 使用 $\\mu * \\text{np.random.randn(…)} + \\sigma$. np.random.randint1np.random.randint(low[, high, size, type]) 返回 $[low, high)$ 范围内的随机整数, 当 high 没有填写时, 默认产生 $[0, low)$ 范围内的随机整数. 默认类型为 np.int. np.random.random_integers1np.random.random_integers(low[, high, size]) 返回 $[low, high]$ 范围内的随机整数, 当 high 没有填写时, 默认生成随机数的范围为 $[1, low]$. 该函数在新版本的 numpy 中已被替代, 建议使用 randint 函数. 生成 [0, 1) 区间的浮点数1234np.random.random(size=None)np.random.sample(size=None)np.random.ranf(size=None)np.random.random_sample(size=None) 以上四个函数都是返回 $[0.0, 1.0)$ 范围内的随机浮点数. 如果要产生服从 $\\text{Unif}(b, a), b &gt; a$ 分布的浮点数, 可以使用 $(b - a) * \\text{random_sample()} + a$. np.random.choice1np.random.choice(a, size=None, replace=True, p=None) 从给定的 一维 数组中随机选取一个样本 参数 a 是整数时, 相当于 np.arange(a). size 为返回数组的大小, 用 tuple 表示. 参数 p 表示数组中数据出现的概率, 数组之和应该为 1, 并且大小要和 a 一样大. replace=False 时, 生成的随机数不能有重复的数值, 这是一个测试 例如: 12345678&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.random.choice(5, size=(3,), replace=False)array([1, 2, 0])&gt;&gt;&gt; np.random.choice(5, size=(6,), replace=False)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"mtrand.pyx\", line 1166, in mtrand.RandomState.choiceValueError: Cannot take a larger sample than population when 'replace=False' Permutationsnp.random.permutation1np.random.permutation(x) 对序列进行随机的非原地排列 (即不是 in-place 的, 会对序列进行拷贝). 如果序列是多维数组, 那么只会沿着第一个 index 进行随机排列. 参数 x 如果是个整数, 那么相当于对 np.arange(x) 进行随机排列. 考虑多维数组的情况, 见下面的例子: 12345&gt;&gt;&gt; a = np.arange(9).reshape(3, 3)&gt;&gt;&gt; np.random.permutation(a)array([[3, 4, 5], [0, 1, 2], [6, 7, 8]]) np.random.shuffle1np.random.shuffle() 对数组/list 进行原地 shuffle. 注意这个函数直接修改数组, 返回 None. 对于多维数组, 只会沿着第一个 index 进行 shuffle. 123456789&gt;&gt;&gt; aarray([[0, 1, 2], [3, 4, 5], [6, 7, 8]])&gt;&gt;&gt; np.random.shuffle(a)&gt;&gt;&gt; aarray([[3, 4, 5], [6, 7, 8], [0, 1, 2]]) Distributionsnp.random.normal1np.random.normal(loc=0.0, scale=1.0, size=None) 对正态 (高斯) 分布进行采样. $$p ( x ) = \\frac { 1 } { \\sqrt { 2 \\pi \\sigma ^ { 2 } } } e ^ { - \\frac { ( x - \\mu ) ^ { 2 } } { 2 \\sigma ^ { 2 } } }$$ 其中 $\\mu$ 称为 mean, 而 $\\sigma$ 称为 standard deviation, $\\sigma^2$ 被称为 variance. 123456&gt;&gt;&gt; mu, sigma = 0, 0.1 # mean and standard deviation&gt;&gt;&gt; s = np.random.normal(mu, sigma, 1000)&gt;&gt;&gt; abs(mu - np.mean(s)) &lt; 0.01True&gt;&gt;&gt; abs(sigma - np.std(s, ddof=1)) &lt; 0.01True np.random.uniform1np.random.uniform(low=0.0, high=1.0, size=None) 对均匀分布进行采样. low 和 size 是可选的. Random Generatornp.random.seed1np.random.seed(seed=None) 设置随机种子, 使结果可重复. 参考资料 为什么你用不好Numpy的random函数? Random sampling (numpy.random)","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://yoursite.com/tags/Numpy/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"Numpy","slug":"程序语言/Python/Numpy","permalink":"http://yoursite.com/categories/程序语言/Python/Numpy/"}]}]}