{"pages":[{"title":"About","date":"2018-11-25T02:31:40.664Z","path":"about/index.html","text":""},{"title":"Categories","date":"2018-11-25T02:31:40.665Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2018-11-25T02:31:40.667Z","path":"tags/index.html","text":""}],"posts":[{"title":"PyTorch-C++ 接口","date":"2019-04-14T04:01:00.000Z","path":"wiki/程序语言/Python/PyTorch/PyTorch-Cpp/","text":"介绍从 https://pytorch.org/ 下载 LibTorch 代码 Hello World写一个 Hello World 程序 123456789#include &lt;iostream&gt;#include &lt;torch/torch.h&gt;using namespace std;int main() &#123; torch::Tensor tensor = torch::rand(&#123;2, 2&#125;); cout &lt;&lt; tensor &lt;&lt; endl;&#125; 编译Makefile 如下: 其中 .../libtorch 中保存着 LibTorch 的代码 12345678910111213141516171819202122TORCH = /Users/zhang/Codes/C++/pytorch-c++/libtorchCC = clang++CFLAGS = -Wall -std=c++0xCFLAGS += -I$(TORCH)/include -L$(TORCH)/libCFLAGS += -I$(TORCH)/include/torch/csrc/api/includeCLINKS = -ltorch.1 -lcaffe2 -lc10NAME = ex1SRC = $(NAME).cppTAR = $(NAME).out$(TAR) : $(SRC) $(CC) $(CFLAGS) -o $@ $^ $(CLINKS).PHONY : run cleanrun : LD_LIBRARY_PATH=$(TORCH)/lib ./$(TAR)clean : rm -rf *.out 参考资料","tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"http://yoursite.com/tags/PyTorch/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"PyTorch","slug":"程序语言/Python/PyTorch","permalink":"http://yoursite.com/categories/程序语言/Python/PyTorch/"}]},{"title":"Docker常用命令","date":"2019-01-05T11:56:29.000Z","path":"wiki/技术开发/Docker/Docker常用命令/","text":"常用命令总结1234567891011121314151617# -t 表示 tag, -f 表示 file, 默认是 Dockerfile, 最后的 . 不要忘了docker build -t ubuntu-16.04:v1 -f Dockerfile.gpu .docker ps -adocker image lsdocker rm container_iddocker rmi image_iddocker run -v /path/of/host:/path/in/constainer -p /port/of/host:/port/of/container -it image_id [command]docker pull image_in_dockerhubdocker commit -a author -m message container_id repository:tag# -a 表示 attach, -i 表示 iterativedocker start -a -i container_id# -f 表示 forcedocker stopdocker kill -f 参考资料","tags":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/tags/技术开发/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"Docker","slug":"技术开发/Docker","permalink":"http://yoursite.com/categories/技术开发/Docker/"}]},{"title":"Make Life Easier","date":"2019-01-03T02:22:30.000Z","path":"wiki/某些Tricks/Make-Life-Easier/","text":"我现在发现, 为什么不用 Docker …是的, 赶紧把 Docker 用熟来. 装好 Docker 和 Nvidia-docker, 然后使用 sshfs 将远程服务器的文件映射到本地, 嗯, 真香~ Docker Documentation NVIDIA-docker Documentation 安装 oh-my-zsh可供参考的资料: https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH https://www.howtoforge.com/tutorial/how-to-setup-zsh-and-oh-my-zsh-on-linux/ 在 Ubuntu 上, 使用: 12345678sudo apt-get install zshchsh -s $(which zsh) # make your default shellexport SHELL=/bin/zsh # if the above command has no effectexec $SHELLsudo apt-get install wget gitwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrcsource ~/.zshrc 安装插件Become A Command-Line Power User With Oh My ZSH And Z 在 ~/.zshrc 中修改 plugins 那一行: 1plugins=(git vi-mode z) 要使用 z 的话, 需要先下载 z.sh 123wget https://github.com/rupa/z/blob/master/z.shmv z.sh ~/.zexec $SHELL 上面这种安装方法我认为是最简单的了, 另外还有一种方法可以参考: Boost Productivity with Z and Zsh on Ubuntu Pyenv 管理多版本的 Python 安装 Pyenv 主页在: https://github.com/pyenv/pyenv, Mac 用户可以使用 Homebrew 安装, 此时安装的路径在: 1/usr/local/Cellar/pyenv 而 Ubuntu 用户可以使用如下一些命令安装 (先把 oh-my-zsh 装好) 12345git clone https://github.com/pyenv/pyenv.git ~/.pyenvecho 'export PYENV_ROOT=\"$HOME/.pyenv\"' &gt;&gt; ~/.zshrcecho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' &gt;&gt; ~/.zshrcecho -e 'if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then\\n eval \"$(pyenv init -)\"\\nfi' &gt;&gt; ~/.zshrcexec $SHELL 加快 Python/Anaconda 的下载速度 要使各个版本的发行版加快下载, 可以修改为清华镜像, 比如我的 anaconda3-4.2.0 文件如下, 其中 https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 是重点, 还有后面一大堆估计是编码的东西也给删掉了. 首先到 Pyenv 的如下目录: 123pyenv_root='~/.pyenv' # Ubuntupyenv_root=/usr/local/Cellar/pyenv # Mac$(pyenv_root)/1.2.7/plugins/python-build/share/python-build 然后修改 anaconda3-4.2.0 文件, 这里给的例子是修改 OSX 系统的: 1234567891011121314151617181920case \"$(anaconda_architecture 2&gt;/dev/null || true)\" in\"Linux-x86\" ) install_script \"Anaconda3-4.2.0-Linux-x86\" \"https://repo.continuum.io/archive/Anaconda3-4.2.0-Linux-x86.sh#1a8320635f2f06ec9d8610e77d6d0f9cb2c5d11d20a4ff7fcda113e04b0a8a50\" \"anaconda\" verify_py35 ;;\"Linux-x86_64\" ) install_script \"Anaconda3-4.2.0-Linux-x86_64\" \"https://repo.continuum.io/archive/Anaconda3-4.2.0-Linux-x86_64.sh#73b51715a12b6382dd4df3dd1905b531bd6792d4aa7273b2377a0436d45f0e78\" \"anaconda\" verify_py35 ;;\"MacOSX-x86_64\" ) #install_script \"Anaconda3-4.2.0-MacOSX-x86_64\" \"https://repo.continuum.io/archive/Anaconda3-4.2.0-MacOSX-x86_64.sh#95448921601e1952e01a17ba9767cd3621c154af7fc52dd6b7f57d462155a358\" \"anaconda\" verify_py35 install_script \"Anaconda3-4.2.0-MacOSX-x86_64\" \"https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-4.2.0-MacOSX-x86_64.sh\" \"anaconda\" verify_py35 ;;* ) &#123; echo colorize 1 \"ERROR\" echo \": The binary distribution of Anaconda3 is not available for $(anaconda_architecture 2&gt;/dev/null || true).\" echo &#125; &gt;&amp;2 exit 1 ;;esac 修改 Pip 的镜像修改 ~/.pip/pip.conf 文件如下: 12345[global]index-url=http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com conda 设置清华镜像Anaconda | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror 123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes 参考资料","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"工具性网站总结","date":"2018-12-16T14:32:34.000Z","path":"wiki/网络资源/工具性网站总结/","text":"https://sm.ms/ 好用的图床, 我目前 Wiki 的图像都是上传到这个网站上, 但是图像大小有限制, 5Mb 以内. https://www.soogif.com/compress Gif 图像压缩, 这个压缩力度感觉很猛… https://www.iloveimg.com/zh-cn/compress-image 图像压缩, 也很不错, 和上面那个结合使用 免费图床总结 参考资料","tags":[{"name":"Resource","slug":"Resource","permalink":"http://yoursite.com/tags/Resource/"}],"categories":[{"name":"网络资源","slug":"网络资源","permalink":"http://yoursite.com/categories/网络资源/"}]},{"title":"Hexo引用站内文章","date":"2018-12-16T13:08:02.000Z","path":"wiki/某些Tricks/Hexo引用站内文章/","text":"在写博客的过程中需要引用自己写的文章, 根据下面的参考资料 1 中所述, 可以使用内置的标签插件的语法 post_link 来实现引用, 具体的语法是: 12&#123;% post_link 文章文件名(不要后缀) 文章标题(可选) %&#125;# &#123;% post_link slug [title] %&#125; 其中 slug 就是 _posts 文件夹下需要引用的文章的 markdown 文件的名字，title 可以指定引用的文章需要显示的名字. 举个例子, 我的 Wiki 中 程序语言-&gt;Python-&gt;实用程序-&gt;查找相似图片 这篇文章中, 需要引用我的另外两篇文章, 相关写法如下: 12+ &#123;% post_link 程序语言/Python/实用程序/Matplotlib响应按键浏览图片 %&#125;+ &#123;% post_link 程序语言/Python/实用程序/Logger用于log记录 %&#125; 因为这两篇文章都在 source/_posts/程序语言/Python/实用程序/ 目录下. 参考资料 Hexo博客搭建之引用站内文章 Hexo引用站内文章","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"查找相似图片","date":"2018-12-16T12:19:01.000Z","path":"wiki/程序语言/Python/实用程序/查找相似图片/","text":"找相似图片的原理主要有颜色直方图, 感知哈希算法等, 详情可以看参考资料中阮一峰的博客, 相当之详细. 先看看效果吧: ImageSimilarity 实现要运行该代码, 对于 python 库, 主要需要安装 pillow 以及 tqdm. 另外, 还需要我写的 ImageViewer.py 以及 Logger.py 文件, 它们分别可以在如下位置找到: Matplotlib响应按键浏览图片 Logger用于log记录 下面实现的 Finder 对象中的 find_all 方法, 传入要搜寻的目录, 从该目录中找到和目标图像相似的图像. 如果在运行程序时, 设置 --show True, 那么可以使用 ImageViewer 提供的功能, 方便的通过快捷键浏览图像. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import argparseimport globimport osimport sysimport numpy as npfrom os.path import join, existsfrom functools import reducefrom datetime import datetimeimport matplotlib.pyplot as pltfrom PIL import Imagefrom tqdm import tqdmfrom ImageViewer import ImageViewerfrom Logger import InfoLogger, args_namespaceparser = argparse.ArgumentParser('Find Similar Images')parser.add_argument('--log_checkpoint', type=str, default='./infologger', help=\"log files savepath\")parser.add_argument('--log_file', type=str, default=\"&#123;:%Y-%m-%d-%H:%M:%S&#125;.log\".format(datetime.now()), help='logfile name')parser.add_argument('--image', type=str, default=\"./Set14/monarch.png\", help='base image name')parser.add_argument('--search', type=str, default=\"./bsd100\", help='which dir to search similar images')parser.add_argument('--rank', type=int, default=10, help='how many similar images to search')parser.add_argument('--method', type=str, default='color_hist', help='similar image algorithm, &#123;color_hist | avhash&#125;')parser.add_argument('--show', type=str, default='False', help='whether show similar images or not')parser.add_argument('--savepath', type=str, default='./ResultImgs', help='path to save base image and similar_imgs')opt = parser.parse_args()logger = InfoLogger(opt)logger.info(args_namespace(opt))class Finder(object): def __init__(self, img_path): self.base_img = img_path self.similar_imgs = [] def find_indir(self, img_dir, rank=20, method='color_hist'): \"\"\"method = &#123;'color_hist' | 'avhash'&#125;\"\"\" logger.info('Find similar image of: &#123;&#125;'.format(self.base_img)) logger.info('Searching directory: &#123;&#125;'.format(img_dir)) seq = [] if method == 'avhash': base_h = self.avhash(self.base_img) for filename in tqdm(os.listdir(img_dir)): fullname = join(img_dir, filename) seq.append((fullname, self.hamming(self.avhash(fullname), base_h))) elif method == 'color_hist': for filename in tqdm(os.listdir(img_dir)): fullname = join(img_dir, filename) seq.append((fullname, -1 * self.color_hist(self.base_img, fullname, mode=2))) for idx, (f, ham) in enumerate(sorted(seq, key=lambda i: i[1])): if idx &gt;= rank: break logger.info(\"&#123;&#125;\\t&#123;&#125;\".format(ham, f)) self.similar_imgs.append(f) def show_similar_imgs(self): im = np.array(Image.open(self.base_img).convert('RGB')) fig, ax = plt.subplots() ax.imshow(im) ax.set_title('Base Image') viewer = ImageViewer(self.similar_imgs) viewer.fig.suptitle('Similar Images') viewer.show() # https://blog.csdn.net/birdy_/article/details/78822901 # https://blog.csdn.net/Mengwei_Ren/article/details/73359298 # base on color histogram def difference(self, hist1, hist2): sum1 = 0 for i in range(len(hist1)): if (hist1[i] == hist2[i]): sum1 += 1 else: sum1 += 1 - float(abs(hist1[i] - hist2[i])) / max(hist1[i], hist2[i]) return sum1/len(hist1) def color_hist(self, path1 , path2 , mode=2): if(mode == 3): img1 = Image.open(path1).resize((8,8)).convert('1') img2 = Image.open(path2).resize((8,8)).convert('1') hist1 = list(img1.getdata()) hist2 = list(img2.getdata()) return self.difference(hist1, hist2) # preprocess img1 = Image.open(path1).resize((256,256)).convert('RGB') img2 = Image.open(path2).resize((256,256)).convert('RGB') if(mode == 1): return self.difference(img1.histogram(), img2.histogram()) if(mode == 2): sum = 0 for i in range(4): for j in range(4): hist1 = img1.crop((i*64, j*64, i*64+63, j*64+63)).copy().histogram() hist2 = img2.crop((i*64, j*64, i*64+63, j*64+63)).copy().histogram() sum += self.difference(hist1, hist2) return sum/16 # http://www.ruanyifeng.com/blog/2011/07/principle_of_similar_image_search.html # base on Perceptual hash algorithm def avhash(self, im): if not isinstance(im, Image.Image): im = Image.open(im) im = im.resize((8, 8), Image.ANTIALIAS).convert('L') avg = reduce(lambda x, y: x + y, im.getdata()) / 64. return reduce(lambda x, yz: x | (yz[1] &lt;&lt; yz[0]), \\ enumerate(map(lambda i: 0 if i &lt; avg else 1, im.getdata())), \\ 0) def hamming(self, h1, h2): h, d = 0, h1 ^ h2 while d: h += 1 d &amp;= d - 1 return hif __name__ == '__main__': finder = Finder(opt.image) finder.find_indir(opt.search, rank=opt.rank, method=opt.method) if opt.show == 'True': finder.show_similar_imgs() 参考资料 相似图片搜索的原理 相似图片搜索的原理（二） 【python + PIL】图像相似度检测 【图像处理】图像检索的三种python实现(直方图/OpenCV/哈希法)","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://yoursite.com/tags/Matplotlib/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"实用程序","slug":"程序语言/Python/实用程序","permalink":"http://yoursite.com/categories/程序语言/Python/实用程序/"}]},{"title":"Logger用于log记录","date":"2018-12-16T11:11:57.000Z","path":"wiki/程序语言/Python/实用程序/Logger用于log记录/","text":"写程序进行日志记录真的非常方便, 这里提供 InfoLogger 类, 用于对日志的记录. 比如: 12logger = InfoLogger(opt=None)logger.info('Hello World') 默认创建 log/ 文件夹并在该文件夹中记录日志, 如果要修改目录, 那么就要传入 opt 对象, 该对象需要分别指定 opt.log_checkpoint 属性说明日志存放的目录, 以及 opt.log_file 属性: log 文件的名字. 另外还提供 args_namespace 函数, 用于处理 argparse.Namespace 对象 (即 opt = parser.parse_args()). 具体效果看下面的内容. 关于 opt 对象, 有 log_checkpoint 或 log_file 就行, 没有这两个属性就采用默认值. 1234567parser = argparse.ArgumentParser('Logger')parser.add_argument('--log_checkpoint', type=str, default='log/', help='log directory')opt = parser.parse_args()# oropt = type('Option', (object,), &#123;&#125;)opt.log_checkpoint = 'log/' InfoLogger 类的实现Logger.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import loggingfrom datetime import datetimefrom pprint import pprint as ppfrom os.path import exists, joinimport osdef args_namespace(opt): res = [\"&#123;&#125;: &#123;&#125;\\n\".format(attr, getattr(opt, attr)) for attr in vars(opt)] return \"Argument Settings:\\n\" + \\ \"===============================================================\\n\" + \\ \"\".join(res) + \\ \"===============================================================\"class InfoLogger(object): def __init__(self, opt=None): super(InfoLogger, self).__init__() if not getattr(opt, 'log_checkpoint', None): log_checkpoint = 'log' else: log_checkpoint = opt.log_checkpoint if not getattr(opt, 'log_file', None): log_file = \"&#123;:%Y-%m-%d-%H:%M:%S&#125;.log\".format(datetime.now()) else: log_file = opt.log_file if not exists(log_checkpoint): os.makedirs(log_checkpoint) logging.basicConfig(level=logging.INFO) self.logger = logging.getLogger('main') handler = logging.FileHandler(join(log_checkpoint, log_file), mode='w') handler.setLevel(logging.INFO) formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S') handler.setFormatter(formatter) self.logger.addHandler(handler) def __getattr__(self, item): return self.logger.__getattribute__(item)if __name__ == '__main__': # you can also use argparse, I use `type` here just for convenience. opt = type('Option', (object, ), &#123;&#125;) opt.log_checkpoint = './infologger' opt.log_file = 'test.log' logger = InfoLogger(opt) logger.info(args_namespace(opt)) logger.info('hello world') demo 效果如下: 参考资料","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"实用程序","slug":"程序语言/Python/实用程序","permalink":"http://yoursite.com/categories/程序语言/Python/实用程序/"}]},{"title":"Matplotlib响应按键浏览图片","date":"2018-12-16T11:10:40.000Z","path":"wiki/程序语言/Python/实用程序/Matplotlib响应按键浏览图片/","text":"最近写了一个查找相似图像的算法, 目标是给定 A 图片, 然后在目录 B/ 中查找和 A 图片相似的图片. 假设在 B/ 中我找到了 10 张相似图片, 但是要查看这 10 张图, 在 Mac 上我先到文件夹下, 然后使用 preview 进行查看, 有点麻烦, 我想是否可以用 matplotlib 显示这些图片, 然后按下 n 就浏览下一张, 按下 N 浏览上一张. 于是就有了下面的脚本, 同时复习一下 Matplotlib 的事件处理代码如何写. ImageViewer 类的实现ImageViewer 类的具体实现如下, img_list 是包含图像绝对路径的 list. 代码最后给了 demo, 很简单. demo 中的效果是浏览一个文件夹中的图片, 按 n 访问下一张, 按 N 访问上一张. ImageViewer.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import numpy as npfrom PIL import Imageimport matplotlibimport matplotlib.pyplot as pltclass ImageViewer(object): def __init__(self, img_list): self.img_list = list(img_list) self.fig, self.ax = plt.subplots() self.num_of_img = len(self.img_list) self.indicator = 0 self.connect() def path2array(self, img_path): im = Image.open(img_path).convert('RGB') im = np.array(im) return im def show(self): if self.img_list: im = self.path2array(self.img_list[self.indicator]) self.ax.imshow(im) plt.show() def connect(self): self.cidkey = self.fig.canvas.mpl_connect( 'key_press_event', self.on_keypress) def on_keypress(self, event): if self.img_list: if event.key in ['n']: self.indicator += 1 elif event.key in ['N']: self.indicator -= 1 # dont worry about negative self.indicator, % will automatically handle it self.indicator = self.indicator % self.num_of_img im = self.path2array(self.img_list[self.indicator]) self.ax.imshow(im) self.fig.canvas.draw()if __name__ == '__main__': import os from os.path import join, exists img_dir = './bsd100' img_list = [join(img_dir, name) for name in os.listdir(img_dir)] viewer = ImageViewer(img_list) viewer.show() 按键响应Matplotlib 提供 key_press_event, 回调函数为 self.on_keypress. 在该函数中, 使用 self.indicator 记录当前指向第几张图片 (从 0 开始计数). 为了循环访问的效果, 使用求余符号 % 控制 self.indicator 的变化. 1234567891011121314151617def connect(self): self.cidkey = self.fig.canvas.mpl_connect( 'key_press_event', self.on_keypress)def on_keypress(self, event): if self.img_list: if event.key in ['n']: self.indicator += 1 elif event.key in ['N']: self.indicator -= 1 # dont worry about negative self.indicator, % will automatically handle it self.indicator = self.indicator % self.num_of_img im = self.path2array(self.img_list[self.indicator]) self.ax.imshow(im) self.fig.canvas.draw() 参考资料","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://yoursite.com/tags/Matplotlib/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"实用程序","slug":"程序语言/Python/实用程序","permalink":"http://yoursite.com/categories/程序语言/Python/实用程序/"}]},{"title":"有意思的Github项目","date":"2018-11-28T15:08:11.000Z","path":"wiki/网络资源/有意思的Github项目/","text":"Git 相关 An interactive git visualization to challenge and educate! 将 Git 的操作可视化, 我觉得之后对于 Git 的学习会很有帮助! 科研GAN Pytorch-based tools for visualizing and understanding the neurons of a GAN. 现在 GAN 的发展简直太快了… 参考资料","tags":[{"name":"Resource","slug":"Resource","permalink":"http://yoursite.com/tags/Resource/"}],"categories":[{"name":"网络资源","slug":"网络资源","permalink":"http://yoursite.com/categories/网络资源/"}]},{"title":"DetailViewer简要介绍","date":"2018-11-27T06:56:46.000Z","path":"wiki/程序语言/Python/Matplotlib/DetailViewer简要介绍/","text":"DetailViewer 简要介绍DetaiViewer 是用来放大图像细节的工具, 它意在帮助从事底层图像处理的科研人员方便对比各种算法的效果. 比如在图像去噪, 图像超分辨率的论文中, 我们常常需要将自己的算法和其他的 state-of-the-art 的算法进行视觉效果上的比较, DetailViewer 就是为了方便这一过程, 效果如下图: 下面介绍使用 Python 和 Matplotlib 实现 DetailViewer 的过程. DetailViewer 包含两个主要的 API: FigureInfo class RectangleSelection class 其中最为重要的是 RectangleSelection 这个类了, 你可以直接将一个 matplotlib.figure.Figure 对象传入到这个类中, 然后就可以利用其中的画出正方形以及移动正方形并动态显示图像细节等功能. 而 FigureInfo 只是根据你传入的图像大小和数量简单设置这些图像的布局, 这部分内容其实你自己也可以写. 下面首先重点说一下 RectangleSelection 的实现. 在详细说明细节之前, 先介绍一下我的编程环境: 12345Anaconda Python 3.5.6Matplotlib 3.0.0 # 注意 Matplotlib 的版本至少是 3.0.0, 因为会用到 matplotlib.axes.Axes 对象的 inset_axes 方法.Numpy 1.14.2PIL (pillow) 5.1.0scikit-image 0.14.0 面向对象 API首先需要认识 Matplotlib 中的 Artist, 关于这一点, 可以详细学习 Matplotlib Artist Tutorial, Artists 主要有两种类型: primitives 和 containers. 像 Line2D, Rectangle, Text, AxesImage 等都属于 primitives, 而 Axes 和 Subplots 就属于 containers. 明确 Artists 的概念后, 再来理解一下 Axes 和 Subplots 的关系, 比如对于如下代码: 1fig, ax = plt.subplots() 它返回两个对象: matplotlib.figure.Figure 以及 matplotlib.axes.Axes, 上面那句代码相当于如下: 12345fig = plt.figure()ax = fig.add_subplot(111)# 和下面的代码还是有一些差异的, 但是本质上是类似的ax = fig.add_axes([0., 0., 1., 1.]) 另外需要注意的是 plt.subplots() 会返回一个 Axes 对象或者一个 Numpy 数组, 比如: 12345678910111213141516&gt;&gt;&gt; fig, ax = plt.subplots()&gt;&gt;&gt; print(ax)AxesSubplot(0.125,0.11;0.775x0.77)&gt;&gt;&gt; fig, axes = plt.subplots(2, 2)&gt;&gt;&gt; print(repr(axes))array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x11537a160&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x115392748&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1153a9cc0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x11744b278&gt;]], dtype=object)&gt;&gt;&gt; print(axes.shape)(2, 2)# 由于这里 axes 的 shape 是 (2, 2), 那么之后为了用 for 循环方便访问每个 ax, 可以使用:# for ax in axes.ravel() (或者使用 axes.flat) 所以在代码中, 为了处理的统一性, 我会对 ax 使用 ax = np.array(ax) 进行转换, 方便处理, 防止用户只传入一张图片. Matplotlib 中的事件处理和 pickingMatplotlib 提供如下事件处理, 更为详细的信息请查看: https://matplotlib.org/users/event_handling.html 在 DetailViewer 中的 RectangleSeletion 类中, 事件处理使用 connect 方法完成: 1234567891011def connect(self): self.cidpress = self.fig.canvas.mpl_connect( 'button_press_event', self.on_press) self.cidmotion = self.fig.canvas.mpl_connect( 'motion_notify_event', self.on_motion) self.cidpick = self.fig.canvas.mpl_connect( 'pick_event', self.on_pick) self.cidrelease = self.fig.canvas.mpl_connect( 'button_release_event', self.on_release) self.cidkey = self.fig.canvas.mpl_connect( 'key_press_event', self.on_keypress) 从上至下依次是: 鼠标按下事件: 确认鼠标的位置, 判断鼠标是否在某个 Axes 中; 只允许画一个矩形; 鼠标移动事件: 确认鼠标位置; 确认用户有画矩形的意图; 用户画出矩形; 用户移动矩形的处理方式; 矩形移动事件: 用户如果移动矩形, 各种状态的变化; 鼠标释放事件: 各种状态的变化; 如果用户画出了矩形, 那么要放大图像; 按键响应事件: 针对用户按下键盘上的按键, 做出相应的响应. 每个事件要跟一个操作进行联系, 需要使用 FigureCanvasBase.mpl_connect 方法, 比如 self.fig.canvas.mpl_connect 方法, 该方法返回一个事件 connection id, 简称 cid, 之后可以用于 mpl_disconnect 方法. 下面依次介绍各个事件. 状态变量12345678910class RectangleSelection(object): def __init__(self, fig): self.fig = fig # 画板 self.cur_axes = None # 鼠标当前所在的 axes self.rect = None # 用户画出的矩形 self.x0, self.y0 = None, None # 矩形的左上角坐标 self.x1, self.y1 = None, None # 矩形的右下角坐标 self.is_picking = False # 用户是否选中了矩形 self.sub_axes = list() # 保存图像上所有的轴域 self.connect() # 将事件与 handling 进行关联 鼠标按下事件:12 参考资料 Matplotlib User’s Guide: Interactive plots","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://yoursite.com/tags/Matplotlib/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"Matplotlib","slug":"程序语言/Python/Matplotlib","permalink":"http://yoursite.com/categories/程序语言/Python/Matplotlib/"}]},{"title":"Ubuntu软件安装","date":"2018-11-27T06:36:45.000Z","path":"wiki/技术开发/Unix/Ubuntu/Ubuntu软件安装/","text":"Ubuntu 安装 gcc-4.9参考: Getting + installing gcc/g++ 4.9 on Ubuntu? 1234567891011sudo su -apt-get install build-essentialadd-apt-repository ppa:ubuntu-toolchain-r/testapt-get updateapt-get install gcc-4.9 g++-4.9 cpp-4.9cd /usr/binrm gcc g++ cppln -s gcc-4.9 gccln -s g++-4.9 g++ln -s cpp-4.9 cpp 除了使用软连接, 还可以使用 update-alternatives 来修改 gcc 默认的版本, 具体可以参考上面的参考资料. systemctl: command not found参考: systemctl: command not found on ubuntu 16.04 1234sudo apt-get install systemd# 如果软件损坏, 重装的方法sudo apt-get reinstall systemd frpc 设置开机自启动参考: Github: frp怎样开机启动和后台运行? 在 /etc/systemd/system/ 中添加 frpc.service 文件, 内容如下: 1234567891011121314[Unit]Description=frpc daemonAfter=syslog.target network.targetWants=network.target[Service]Type=simpleExecStart=/home/ieric/Programs/frp_0.20.0_linux_amd64/frpc -c /home/ieric/Programs/frp_0.20.0_linux_amd64/frpc.iniRestart= alwaysRestartSec=1minExecStop=/usr/bin/killall frpc[Install]WantedBy=multi-user.target 再修改一下 mode, sudo chmod a+x frpc.service. 在 frpc.ini 配置文件中设置 login_fail_exit 的值为 false (默认是 true), 这样的话, 当启动时没有连上服务器就不会立即退出, 而是每隔 30s 自动重连. 完成以上两步之后, 使用 1234567sudo systemctl enable frpcsudo systemctl status frpc# 这是输出状态frpc.service - frpc daemon Loaded: loaded (/etc/systemd/system/frpc.service; enabled) Active: inactive .... 重启与关机12sudo reboot -nfsudo shutdown now 参考资料","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"Unix","slug":"技术开发/Unix","permalink":"http://yoursite.com/categories/技术开发/Unix/"},{"name":"Ubuntu","slug":"技术开发/Unix/Ubuntu","permalink":"http://yoursite.com/categories/技术开发/Unix/Ubuntu/"}]},{"title":"编程资源汇总","date":"2018-11-26T15:25:18.000Z","path":"wiki/网络资源/编程资源汇总/","text":"编程资源总结 Github: 免费的编程中文书籍索引 简书: 程序员书籍汇总下载 Github: python中文库-python人工智能大数据自动化接口测试开发 Github: Machine Learning for OpenCV 参考资料","tags":[{"name":"Resource","slug":"Resource","permalink":"http://yoursite.com/tags/Resource/"}],"categories":[{"name":"网络资源","slug":"网络资源","permalink":"http://yoursite.com/categories/网络资源/"}]},{"title":"vim技巧","date":"2018-11-26T15:11:51.000Z","path":"wiki/技术开发/Unix/Vim/vim技巧/","text":"调整窗口的高度和宽度参考博客 1. 其中使用 c-w, &gt; 和 c-w, &lt; 最为方便. 12345678910111213141516171819CTRL-W = 使得所有窗口 (几乎) 等宽、等高，但当前窗口使用 'winheight' 和 'winwidth'。:res[ize] -N CTRL-W - 使得当前窗口高度减 N (默认值是 1)。如果在 'vertical' 之后使用，则使得宽度减 N。:res[ize] +N CTRL-W + 使得当前窗口高度加 N (默认值是 1)。如果在 'vertical' 之后使用，则使得宽度加 N。:res[ize] [N]CTRL-W CTRL-_ CTRL-W _ 设置当前窗口的高度为 N (默认值为最大可能高度)。:vertical res[ize] [N] CTRL-W | 设置当前窗口的宽度为 N (默认值为最大可能宽度)。z&#123;nr&#125;&lt;CR&gt; 设置当前窗口的高度为 &#123;nr&#125;。 CTRL-W &lt; 使得当前窗口宽度减 N (默认值是 1)。 CTRL-W &gt; 使得当前窗口宽度加 N (默认值是 1)。 参考资料 vim: vs sp 调整窗口高度和宽度","tags":[{"name":"Unix","slug":"Unix","permalink":"http://yoursite.com/tags/Unix/"},{"name":"Vim","slug":"Vim","permalink":"http://yoursite.com/tags/Vim/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"Unix","slug":"技术开发/Unix","permalink":"http://yoursite.com/categories/技术开发/Unix/"},{"name":"Vim","slug":"技术开发/Unix/Vim","permalink":"http://yoursite.com/categories/技术开发/Unix/Vim/"}]},{"title":"稀疏表示去噪","date":"2018-11-26T14:00:14.000Z","path":"wiki/专业研究/稀疏表示去噪/","text":"稀疏表示能去噪的原因下面的论述来自参考博客一. 可以认为含噪（观测）图像是由无噪（原始）图像和噪声合成的图像，而观测图像被认为是可稀疏的，即可以通过有限个原子来表示，而噪声是随机的不可稀疏的，即不可以通过有限个原子表示，因此通过观测图像去提取图像的系数成分，再用这些稀疏成分来重构图像，在这个过程中，噪声被处理为观测图像和重构图像之间的残差，在重构过程中残差被丢弃，从而达到去噪的效果。稀疏表示又称为稀疏编码，这个过程可以被视为特征提取的过程，可以看作把目标信号投影到一组非正交的基构成的空间中，而在每个基上投影的系数，就是稀疏编码。这组非正交的基向量中，每一个基向量被称为一个原子，这些原子（列向量）可以构成一个超完备的字典。那么，为什么要使用过完备的字典，或者说要在非正交的空间进行投影呢？对于一组正交基而言，它们可以准确而唯一地表示空间中的任何向量，而且这些向量间没有冗余（因为正交），正式因为严格的正交限制，因此正交基的展开简单，但是稀疏性不够理想，因为严格正交的基往往只能表示图像的某一个特征而不能够同时表示其他特征，因此正交基的稀疏性不及非正交基(过完备字典). 参考资料 稀疏表示去噪的理解","tags":[{"name":"专业研究","slug":"专业研究","permalink":"http://yoursite.com/tags/专业研究/"}],"categories":[{"name":"专业研究","slug":"专业研究","permalink":"http://yoursite.com/categories/专业研究/"}]},{"title":"Git多用户","date":"2018-11-25T15:29:18.000Z","path":"wiki/某些Tricks/Git多用户/","text":"设置 SSH使用 ssh-keygen 产生新的秘钥, 然后将 .pub 放到 Github 上. 之后修改 .ssh/config 文件, 设置 1234Host xzml HostName github.com User git IdentityFile ~/.ssh/id_rsa_xzml 最后使用 ssh -T xzml 对 Github 进行访问, 如果成功的话, 会返回: 1Hi xzml! You've successfully authenticated, but GitHub does not provide shell access. 参考资料","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"Mac下使用Hexo+Github搭建个人博客","date":"2018-11-25T14:58:43.000Z","path":"wiki/某些Tricks/Mac下使用Hexo-Github搭建个人博客/","text":"准备工作建议看看参考博客中的第一个, 图文并茂, 可以感受到很多细节, 作者非常用心, 第二个参考博客是更新奇的内容, 包括插入图片, 购买域名等. 安装 Nodejs 和 npmHexo 是用 Nodejs 写成了, 所以需要先安装 Nodejs 和 npm, 推荐使用 Homebrew 安装. 安装完 Nodejs 后建议设置 npm 淘宝镜像. 1234567brew install nodenpm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global# 查看版本号node -vnpm -v 安装 Hexo1234npm install -g hexo# 查看版本号hexo -v 本地调试创建某个目录用于存放你的博客, 比如我创建了 PWiki/ 文件夹用于存放博客相关的文件, 然后执行如下命令: 123456hexo init # 首先初始化 Hexo, 会将相关的文件从 Github 上下载下来, 默认使用 landscape 主题npm install # 在部署博客之前需要安装依赖项, 我想这个命令会直接读取 PWiki/package.json 文件中的内容hexo generate # 生成静态页面, Hexo 是一个博客框架, 只有执行了 generate 命令才能生成具体的 html, css 等文件hexo server # 启动服务, 用于本地调试hexo clean # 可以清除已经产生的静态页面, 如 PWiki/publish 目录hexo new # 创建新博客 本地打开 http://localhost:4000 进行效果查看 命令缩写: 123hexo generate # 缩写 hexo ghexo server # 缩写 hexo shexo new # 缩写 hexo n 部署到 Github 首先在 Github 上创建名为 &lt;user&gt;.github.io 的 repository, 我的 &lt;user&gt; 就是 xzml. 然后在 PWiki/_config.yml 文件的 deploy 项下, 增加如下内容: 1234deploy: type: git repository: git@github.com:xzml/xzml.github.io.git branch: master 安装 Github 部署器: 1npm install hexo-deployer-git --save 否则应该会出现 ERROR Deployer not found: git 错误. 将静态博客部署到 Github 上: 1hexo deploy # 缩写 hexo d 更换主题按照 https://github.com/zthxxx/hexo-theme-Wikitten 中的 README.md 操作就可以了. 大致思路就是: 从 Github 上将主题下载到 PWiki/ 下的 themes 目录下 修改 PWiki/themes/Wikitten/_config.yml 文件, 对主题进行配置 修改 PWiki/_config.yml 文件, 对项目进行配置, 比如将 theme 这一项更改为 Wikitten. 另外需要注意的是 Wikitten 主题需要额外的一些插件, README.md 中写了, 为了安装它们, 我在 PWiki/package.json 直接增加了如下部分: 1234567891011121314151617\"dependencies\": &#123; \"hexo\": \"^3.7.0\", \"hexo-autonofollow\": \"^1.0.1\", \"hexo-deployer-git\": \"^0.3.1\", \"hexo-directory-category\": \"^1.0.5\", \"hexo-generator-archive\": \"^0.1.5\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-feed\": \"^1.2.2\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-json-content\": \"^3.0.1\", \"hexo-generator-sitemap\": \"^1.2.0\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.3.1\", \"hexo-renderer-marked\": \"^0.3.2\", \"hexo-renderer-stylus\": \"^0.3.3\", \"hexo-server\": \"^0.3.1\"&#125; 然后再使用 npm install 命令安装即可. 还有要注意修改主题的 _config.yml 文件, 将原作者的个人信息改成自己的信息. 保存博客到仓库我们自己使用 hexo new &lt;title&gt; 产生的博客源文件一般是放在 PWiki/source/_posts/ 目录下, 使用 hexo generate 命令产生的静态页面一般是放在 PWiki/publish/ 文件夹下. 为了对博客的 Markdown 源文件以及博客使用的主题进行备份, 参考 Wikitten 原作者的方法, 我在 Github 上创建了一个名为 Wiki-site 的仓库用于存储这些源文件. 具体方法是: 在 Github 上创建一个名为 Wiki-site 的新仓库; 在本地上的 PWiki/ 目录下使用 git init 命令; 修改 PWiki/ 项目中的 .gitignore 文件, 过滤掉那些不需要追踪版本的文件; 另外要注意的问题是, 由于 PWiki/themes/Wikitten 是个 git submodule, 在 PWiki/ 目录下直接使用 git add * 之类的命令可能会引起一些 Warning, 我的做法是到 PWiki/themes/Wikitten/ 目录下先用 git add/commit 等命令处理好后, 再回到 PWiki/ 目录使用 git add/commit 命令; 回到 PWiki/ 目录, 将上面的修改都 git add/commit; 将本地项目与远程服务器进行关联, git remote add origin git@github.com:xzml/Wiki-site.git (具体可以参考第 5 个博客) 执行 git pull origin master, 将远程服务器中的 master 分支和本地的 origin 合并, 防止冲突. 上面没有报错之后, 可以使用 git status 查看当前本地仓库是不是干净的, 如果是的话, 就可以使用 git push -u origin master 推送到 Github 上了. 上面的步骤其实已经将问题给搞定了, 这里记录一个我出现的问题: 我有多个 Github 账号, 即使设置了 PWiki/ 的 local user 为 xzml, 在使用 git push -u origin master 时, 仍会使用另一个 userb. 由于我访问 Github 使用的是 SSH, 这说明访问 `git@github.com时使用的是 userb, 为了使通过 SSH 访问git@github.com使用 xzml, 我直接修改PWiki/.git/config文件中的url = xzml:xzml/Wiki-site.git, 这是因为我在.ssh/config给通过 xzml 访问git@github.com这一行为设置了别名为xzml`. 参考资料 Mac 下 Hexo 和 GitHub-Pages 搭建个人博客（一） Mac 下 Hexo 和 GitHub-Pages 搭建个人博客（二） macOS环境下利用Github和Hexo部署博客 使用 Hexo 生成静态博客过程记录 使用Git命令把本地项目上传到Github托管","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"关于Wiki的主题","date":"2018-11-25T14:35:41.000Z","path":"wiki/某些Tricks/关于Wiki的主题/","text":"不可思议的 Tricks比如使用 Markdown 中的列表, 像如下代码是不会显示列表前面的点 $\\bullet$: 1+ `a` 是一个数组 效果如下: a 是一个数组 需要写成: 1+ 参数 `a` 是一个数组. 才能得到想要的效果: 参数 a 是一个数组. 修改 Wikitten 模板的属性修改字体可以去 themes/Wikitten/source/css 目录下, 查看 style.styl 文件, 发现其中还会导入 _variables.styl 文件, 只需要修改该文件中的相关属性即可. 修改代码使用的主题当前我使用的代码主题 (配色) 是 solarized-light, 要查看其它的配色, 可以看 themes/Wikitten/source/css/_highlight 目录, 里面有大量的配色文件, 这些文件的文件名就是某种主题, 只需要将文件名填入 themes/Wikitten/_config.yml 中的 highlight 项目下即可. 比如: 1highlight: solarized-dark # monakai 参考资料参考资料中有 Wikitten 主题的地址, 以及原作者写的关于使用 Hexo 搭建个人 Wiki 的博客. 使用 Hexo 做个人 Wiki 知识管理系统 作者的个人 Wiki 地址 Wikitten 主题地址","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"numpy中的random函数","date":"2018-11-25T11:41:45.000Z","path":"wiki/程序语言/Python/Numpy/numpy中的random函数/","text":"Random Datanp.random.rand1np.random.rand(d0, d1, ..., dn) rand 函数根据给定的维度产生 $[0, 1)$ 之间的随机数, 服从均匀分布 (uniform distribution) np.random.randn1np.random.randn(d0, d1, ..., dn) randn 函数返回服从标准正态分布 ($\\mathcal{N}(0, 1)$) 的随机数, 要返回服从 $\\mathcal{N}(\\mu, \\sigma)$ 的样本, 使用 $\\mu * \\text{np.random.randn(…)} + \\sigma$. np.random.randint1np.random.randint(low[, high, size, type]) 返回 $[low, high)$ 范围内的随机整数, 当 high 没有填写时, 默认产生 $[0, low)$ 范围内的随机整数. 默认类型为 np.int. np.random.random_integers1np.random.random_integers(low[, high, size]) 返回 $[low, high]$ 范围内的随机整数, 当 high 没有填写时, 默认生成随机数的范围为 $[1, low]$. 该函数在新版本的 numpy 中已被替代, 建议使用 randint 函数. 生成 [0, 1) 区间的浮点数1234np.random.random(size=None)np.random.sample(size=None)np.random.ranf(size=None)np.random.random_sample(size=None) 以上四个函数都是返回 $[0.0, 1.0)$ 范围内的随机浮点数. 如果要产生服从 $\\text{Unif}(b, a), b &gt; a$ 分布的浮点数, 可以使用 $(b - a) * \\text{random_sample()} + a$. np.random.choice1np.random.choice(a, size=None, replace=True, p=None) 从给定的 一维 数组中随机选取一个样本 参数 a 是整数时, 相当于 np.arange(a). size 为返回数组的大小, 用 tuple 表示. 参数 p 表示数组中数据出现的概率, 数组之和应该为 1, 并且大小要和 a 一样大. replace=False 时, 生成的随机数不能有重复的数值, 这是一个测试 例如: 12345678&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.random.choice(5, size=(3,), replace=False)array([1, 2, 0])&gt;&gt;&gt; np.random.choice(5, size=(6,), replace=False)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"mtrand.pyx\", line 1166, in mtrand.RandomState.choiceValueError: Cannot take a larger sample than population when 'replace=False' Permutationsnp.random.permutation1np.random.permutation(x) 对序列进行随机的非原地排列 (即不是 in-place 的, 会对序列进行拷贝). 如果序列是多维数组, 那么只会沿着第一个 index 进行随机排列. 参数 x 如果是个整数, 那么相当于对 np.arange(x) 进行随机排列. 考虑多维数组的情况, 见下面的例子: 12345&gt;&gt;&gt; a = np.arange(9).reshape(3, 3)&gt;&gt;&gt; np.random.permutation(a)array([[3, 4, 5], [0, 1, 2], [6, 7, 8]]) np.random.shuffle1np.random.shuffle() 对数组/list 进行原地 shuffle. 注意这个函数直接修改数组, 返回 None. 对于多维数组, 只会沿着第一个 index 进行 shuffle. 123456789&gt;&gt;&gt; aarray([[0, 1, 2], [3, 4, 5], [6, 7, 8]])&gt;&gt;&gt; np.random.shuffle(a)&gt;&gt;&gt; aarray([[3, 4, 5], [6, 7, 8], [0, 1, 2]]) Distributionsnp.random.normal1np.random.normal(loc=0.0, scale=1.0, size=None) 对正态 (高斯) 分布进行采样. $$p ( x ) = \\frac { 1 } { \\sqrt { 2 \\pi \\sigma ^ { 2 } } } e ^ { - \\frac { ( x - \\mu ) ^ { 2 } } { 2 \\sigma ^ { 2 } } }$$ 其中 $\\mu$ 称为 mean, 而 $\\sigma$ 称为 standard deviation, $\\sigma^2$ 被称为 variance. 123456&gt;&gt;&gt; mu, sigma = 0, 0.1 # mean and standard deviation&gt;&gt;&gt; s = np.random.normal(mu, sigma, 1000)&gt;&gt;&gt; abs(mu - np.mean(s)) &lt; 0.01True&gt;&gt;&gt; abs(sigma - np.std(s, ddof=1)) &lt; 0.01True np.random.uniform1np.random.uniform(low=0.0, high=1.0, size=None) 对均匀分布进行采样. low 和 size 是可选的. Random Generatornp.random.seed1np.random.seed(seed=None) 设置随机种子, 使结果可重复. 参考资料 为什么你用不好Numpy的random函数? Random sampling (numpy.random)","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://yoursite.com/tags/Numpy/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"Numpy","slug":"程序语言/Python/Numpy","permalink":"http://yoursite.com/categories/程序语言/Python/Numpy/"}]}]}