{"pages":[{"title":"Categories","date":"2018-11-25T02:31:40.665Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2018-11-25T02:31:40.667Z","path":"tags/index.html","text":""},{"title":"About","date":"2018-11-25T02:31:40.664Z","path":"about/index.html","text":""}],"posts":[{"title":"有意思的Github项目","date":"2018-11-28T15:08:11.000Z","path":"wiki/网络资源/有意思的Github项目/","text":"Git 相关 An interactive git visualization to challenge and educate! 将 Git 的操作可视化, 我觉得之后对于 Git 的学习会很有帮助! 科研GAN Pytorch-based tools for visualizing and understanding the neurons of a GAN. 现在 GAN 的发展简直太快了… 参考资料","tags":[{"name":"Resource","slug":"Resource","permalink":"http://yoursite.com/tags/Resource/"}],"categories":[{"name":"网络资源","slug":"网络资源","permalink":"http://yoursite.com/categories/网络资源/"}]},{"title":"DetailViewer简要介绍","date":"2018-11-27T06:56:46.000Z","path":"wiki/程序语言/Python/Matplotlib/DetailViewer简要介绍/","text":"DetailViewer 简要介绍DetaiViewer 是用来放大图像细节的工具, 它意在帮助从事底层图像处理的科研人员方便对比各种算法的效果. 比如在图像去噪, 图像超分辨率的论文中, 我们常常需要将自己的算法和其他的 state-of-the-art 的算法进行视觉效果上的比较, DetailViewer 就是为了方便这一过程, 效果如下图: 下面介绍使用 Python 和 Matplotlib 实现 DetailViewer 的过程. DetailViewer 包含两个主要的 API: FigureInfo class RectangleSelection class 其中最为重要的是 RectangleSelection 这个类了, 你可以直接将一个 matplotlib.figure.Figure 对象传入到这个类中, 然后就可以利用其中的画出正方形以及移动正方形并动态显示图像细节等功能. 而 FigureInfo 只是根据你传入的图像大小和数量简单设置这些图像的布局, 这部分内容其实你自己也可以写. 下面首先重点说一下 RectangleSelection 的实现. 在详细说明细节之前, 先介绍一下我的编程环境: 12345Anaconda Python 3.5.6Matplotlib 3.0.0 # 注意 Matplotlib 的版本至少是 3.0.0, 因为会用到 matplotlib.axes.Axes 对象的 inset_axes 方法.Numpy 1.14.2PIL (pillow) 5.1.0scikit-image 0.14.0 面向对象 API首先需要认识 Matplotlib 中的 Artist, 关于这一点, 可以详细学习 Matplotlib Artist Tutorial, Artists 主要有两种类型: primitives 和 containers. 像 Line2D, Rectangle, Text, AxesImage 等都属于 primitives, 而 Axes 和 Subplots 就属于 containers. 明确 Artists 的概念后, 再来理解一下 Axes 和 Subplots 的关系, 比如对于如下代码: 1fig, ax = plt.subplots() 它返回两个对象: matplotlib.figure.Figure 以及 matplotlib.axes.Axes, 上面那句代码相当于如下: 12345fig = plt.figure()ax = fig.add_subplot(111)# 和下面的代码还是有一些差异的, 但是本质上是类似的ax = fig.add_axes([0., 0., 1., 1.]) 另外需要注意的是 plt.subplots() 会返回一个 Axes 对象或者一个 Numpy 数组, 比如: 12345678910111213141516&gt;&gt;&gt; fig, ax = plt.subplots()&gt;&gt;&gt; print(ax)AxesSubplot(0.125,0.11;0.775x0.77)&gt;&gt;&gt; fig, axes = plt.subplots(2, 2)&gt;&gt;&gt; print(repr(axes))array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x11537a160&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x115392748&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x1153a9cc0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x11744b278&gt;]], dtype=object)&gt;&gt;&gt; print(axes.shape)(2, 2)# 由于这里 axes 的 shape 是 (2, 2), 那么之后为了用 for 循环方便访问每个 ax, 可以使用:# for ax in axes.ravel() (或者使用 axes.flat) 所以在代码中, 为了处理的统一性, 我会对 ax 使用 ax = np.array(ax) 进行转换, 方便处理, 防止用户只传入一张图片. Matplotlib 中的事件处理和 pickingMatplotlib 提供如下事件处理, 更为详细的信息请查看: https://matplotlib.org/users/event_handling.html 在 DetailViewer 中的 RectangleSeletion 类中, 事件处理使用 connect 方法完成: 1234567891011def connect(self): self.cidpress = self.fig.canvas.mpl_connect( 'button_press_event', self.on_press) self.cidmotion = self.fig.canvas.mpl_connect( 'motion_notify_event', self.on_motion) self.cidpick = self.fig.canvas.mpl_connect( 'pick_event', self.on_pick) self.cidrelease = self.fig.canvas.mpl_connect( 'button_release_event', self.on_release) self.cidkey = self.fig.canvas.mpl_connect( 'key_press_event', self.on_keypress) 从上至下依次是: 鼠标按下事件: 确认鼠标的位置, 判断鼠标是否在某个 Axes 中; 只允许画一个矩形; 鼠标移动事件: 确认鼠标位置; 确认用户有画矩形的意图; 用户画出矩形; 用户移动矩形的处理方式; 矩形移动事件: 用户如果移动矩形, 各种状态的变化; 鼠标释放事件: 各种状态的变化; 如果用户画出了矩形, 那么要放大图像; 按键响应事件: 针对用户按下键盘上的按键, 做出相应的响应. 每个事件要跟一个操作进行联系, 需要使用 FigureCanvasBase.mpl_connect 方法, 比如 self.fig.canvas.mpl_connect 方法, 该方法返回一个事件 connection id, 简称 cid, 之后可以用于 mpl_disconnect 方法. 下面依次介绍各个事件. 状态变量12345678910class RectangleSelection(object): def __init__(self, fig): self.fig = fig # 画板 self.cur_axes = None # 鼠标当前所在的 axes self.rect = None # 用户画出的矩形 self.x0, self.y0 = None, None # 矩形的左上角坐标 self.x1, self.y1 = None, None # 矩形的右下角坐标 self.is_picking = False # 用户是否选中了矩形 self.sub_axes = list() # 保存图像上所有的轴域 self.connect() # 将事件与 handling 进行关联 鼠标按下事件:12 参考资料 Matplotlib User’s Guide: Interactive plots","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://yoursite.com/tags/Matplotlib/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"Matplotlib","slug":"程序语言/Python/Matplotlib","permalink":"http://yoursite.com/categories/程序语言/Python/Matplotlib/"}]},{"title":"Ubuntu软件安装","date":"2018-11-27T06:36:45.000Z","path":"wiki/技术开发/Unix/Ubuntu/Ubuntu软件安装/","text":"systemctl: command not found参考: systemctl: command not found on ubuntu 16.04 1234sudo apt-get install systemd# 如果软件损坏, 重装的方法sudo apt-get reinstall systemd frpc 设置开机自启动参考: Github: frp怎样开机启动和后台运行? 在 /etc/systemd/system/ 中添加 frpc.service 文件, 内容如下: 1234567891011121314[Unit]Description=frpc daemonAfter=syslog.target network.targetWants=network.target[Service]Type=simpleExecStart=/home/ieric/Programs/frp_0.20.0_linux_amd64/frpc -c /home/ieric/Programs/frp_0.20.0_linux_amd64/frpc.iniRestart= alwaysRestartSec=1minExecStop=/usr/bin/killall frpc[Install]WantedBy=multi-user.target 再修改一下 mode, sudo chmod a+x frpc.service. 在 frpc.ini 配置文件中设置 login_fail_exit 的值为 false (默认是 true), 这样的话, 当启动时没有连上服务器就不会立即退出, 而是每隔 30s 自动重连. 完成以上两步之后, 使用 1234567sudo systemctl enable frpcsudo systemctl status frpc# 这是输出状态frpc.service - frpc daemon Loaded: loaded (/etc/systemd/system/frpc.service; enabled) Active: inactive .... 重启与关机12sudo reboot -nfsudo shutdown now 参考资料","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"Unix","slug":"技术开发/Unix","permalink":"http://yoursite.com/categories/技术开发/Unix/"},{"name":"Ubuntu","slug":"技术开发/Unix/Ubuntu","permalink":"http://yoursite.com/categories/技术开发/Unix/Ubuntu/"}]},{"title":"编程资源汇总","date":"2018-11-26T15:25:18.000Z","path":"wiki/网络资源/编程资源汇总/","text":"编程资源总结 Github: 免费的编程中文书籍索引 简书: 程序员书籍汇总下载 Github: python中文库-python人工智能大数据自动化接口测试开发 Github: Machine Learning for OpenCV 参考资料","tags":[{"name":"Resource","slug":"Resource","permalink":"http://yoursite.com/tags/Resource/"}],"categories":[{"name":"网络资源","slug":"网络资源","permalink":"http://yoursite.com/categories/网络资源/"}]},{"title":"vim技巧","date":"2018-11-26T15:11:51.000Z","path":"wiki/技术开发/Unix/Vim/vim技巧/","text":"调整窗口的高度和宽度参考博客 1. 其中使用 c-w, &gt; 和 c-w, &lt; 最为方便. 12345678910111213141516171819CTRL-W = 使得所有窗口 (几乎) 等宽、等高，但当前窗口使用 'winheight' 和 'winwidth'。:res[ize] -N CTRL-W - 使得当前窗口高度减 N (默认值是 1)。如果在 'vertical' 之后使用，则使得宽度减 N。:res[ize] +N CTRL-W + 使得当前窗口高度加 N (默认值是 1)。如果在 'vertical' 之后使用，则使得宽度加 N。:res[ize] [N]CTRL-W CTRL-_ CTRL-W _ 设置当前窗口的高度为 N (默认值为最大可能高度)。:vertical res[ize] [N] CTRL-W | 设置当前窗口的宽度为 N (默认值为最大可能宽度)。z&#123;nr&#125;&lt;CR&gt; 设置当前窗口的高度为 &#123;nr&#125;。 CTRL-W &lt; 使得当前窗口宽度减 N (默认值是 1)。 CTRL-W &gt; 使得当前窗口宽度加 N (默认值是 1)。 参考资料 vim: vs sp 调整窗口高度和宽度","tags":[{"name":"Unix","slug":"Unix","permalink":"http://yoursite.com/tags/Unix/"},{"name":"Vim","slug":"Vim","permalink":"http://yoursite.com/tags/Vim/"}],"categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://yoursite.com/categories/技术开发/"},{"name":"Unix","slug":"技术开发/Unix","permalink":"http://yoursite.com/categories/技术开发/Unix/"},{"name":"Vim","slug":"技术开发/Unix/Vim","permalink":"http://yoursite.com/categories/技术开发/Unix/Vim/"}]},{"title":"稀疏表示去噪","date":"2018-11-26T14:00:14.000Z","path":"wiki/专业研究/稀疏表示去噪/","text":"稀疏表示能去噪的原因下面的论述来自参考博客一. 可以认为含噪（观测）图像是由无噪（原始）图像和噪声合成的图像，而观测图像被认为是可稀疏的，即可以通过有限个原子来表示，而噪声是随机的不可稀疏的，即不可以通过有限个原子表示，因此通过观测图像去提取图像的系数成分，再用这些稀疏成分来重构图像，在这个过程中，噪声被处理为观测图像和重构图像之间的残差，在重构过程中残差被丢弃，从而达到去噪的效果。稀疏表示又称为稀疏编码，这个过程可以被视为特征提取的过程，可以看作把目标信号投影到一组非正交的基构成的空间中，而在每个基上投影的系数，就是稀疏编码。这组非正交的基向量中，每一个基向量被称为一个原子，这些原子（列向量）可以构成一个超完备的字典。那么，为什么要使用过完备的字典，或者说要在非正交的空间进行投影呢？对于一组正交基而言，它们可以准确而唯一地表示空间中的任何向量，而且这些向量间没有冗余（因为正交），正式因为严格的正交限制，因此正交基的展开简单，但是稀疏性不够理想，因为严格正交的基往往只能表示图像的某一个特征而不能够同时表示其他特征，因此正交基的稀疏性不及非正交基(过完备字典). 参考资料 稀疏表示去噪的理解","tags":[{"name":"专业研究","slug":"专业研究","permalink":"http://yoursite.com/tags/专业研究/"}],"categories":[{"name":"专业研究","slug":"专业研究","permalink":"http://yoursite.com/categories/专业研究/"}]},{"title":"Git多用户","date":"2018-11-25T15:29:18.000Z","path":"wiki/某些Tricks/Git多用户/","text":"设置 SSH使用 ssh-keygen 产生新的秘钥, 然后将 .pub 放到 Github 上. 之后修改 .ssh/config 文件, 设置 1234Host xzml HostName github.com User git IdentityFile ~/.ssh/id_rsa_xzml 最后使用 ssh -T xzml 对 Github 进行访问, 如果成功的话, 会返回: 1Hi xzml! You've successfully authenticated, but GitHub does not provide shell access. 参考资料","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"Mac下使用Hexo+Github搭建个人博客","date":"2018-11-25T14:58:43.000Z","path":"wiki/某些Tricks/Mac下使用Hexo-Github搭建个人博客/","text":"准备工作建议看看参考博客中的第一个, 图文并茂, 可以感受到很多细节, 作者非常用心, 第二个参考博客是更新奇的内容, 包括插入图片, 购买域名等. 安装 Nodejs 和 npmHexo 是用 Nodejs 写成了, 所以需要先安装 Nodejs 和 npm, 推荐使用 Homebrew 安装. 安装完 Nodejs 后建议设置 npm 淘宝镜像. 1234567brew install nodenpm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global# 查看版本号node -vnpm -v 安装 Hexo1234npm install -g hexo# 查看版本号hexo -v 本地调试创建某个目录用于存放你的博客, 比如我创建了 PWiki/ 文件夹用于存放博客相关的文件, 然后执行如下命令: 123456hexo init # 首先初始化 Hexo, 会将相关的文件从 Github 上下载下来, 默认使用 landscape 主题npm install # 在部署博客之前需要安装依赖项, 我想这个命令会直接读取 PWiki/package.json 文件中的内容hexo generate # 生成静态页面, Hexo 是一个博客框架, 只有执行了 generate 命令才能生成具体的 html, css 等文件hexo server # 启动服务, 用于本地调试hexo clean # 可以清除已经产生的静态页面, 如 PWiki/publish 目录hexo new # 创建新博客 本地打开 http://localhost:4000 进行效果查看 命令缩写: 123hexo generate # 缩写 hexo ghexo server # 缩写 hexo shexo new # 缩写 hexo n 部署到 Github 首先在 Github 上创建名为 &lt;user&gt;.github.io 的 repository, 我的 &lt;user&gt; 就是 xzml. 然后在 PWiki/_config.yml 文件的 deploy 项下, 增加如下内容: 1234deploy: type: git repository: git@github.com:xzml/xzml.github.io.git branch: master 安装 Github 部署器: 1npm install hexo-deployer-git --save 否则应该会出现 ERROR Deployer not found: git 错误. 将静态博客部署到 Github 上: 1hexo deploy # 缩写 hexo d 更换主题按照 https://github.com/zthxxx/hexo-theme-Wikitten 中的 README.md 操作就可以了. 大致思路就是: 从 Github 上将主题下载到 PWiki/ 下的 themes 目录下 修改 PWiki/themes/Wikitten/_config.yml 文件, 对主题进行配置 修改 PWiki/_config.yml 文件, 对项目进行配置, 比如将 theme 这一项更改为 Wikitten. 另外需要注意的是 Wikitten 主题需要额外的一些插件, README.md 中写了, 为了安装它们, 我在 PWiki/package.json 直接增加了如下部分: 1234567891011121314151617\"dependencies\": &#123; \"hexo\": \"^3.7.0\", \"hexo-autonofollow\": \"^1.0.1\", \"hexo-deployer-git\": \"^0.3.1\", \"hexo-directory-category\": \"^1.0.5\", \"hexo-generator-archive\": \"^0.1.5\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-feed\": \"^1.2.2\", \"hexo-generator-index\": \"^0.2.1\", \"hexo-generator-json-content\": \"^3.0.1\", \"hexo-generator-sitemap\": \"^1.2.0\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-renderer-ejs\": \"^0.3.1\", \"hexo-renderer-marked\": \"^0.3.2\", \"hexo-renderer-stylus\": \"^0.3.3\", \"hexo-server\": \"^0.3.1\"&#125; 然后再使用 npm install 命令安装即可. 还有要注意修改主题的 _config.yml 文件, 将原作者的个人信息改成自己的信息. 保存博客到仓库我们自己使用 hexo new &lt;title&gt; 产生的博客源文件一般是放在 PWiki/source/_posts/ 目录下, 使用 hexo generate 命令产生的静态页面一般是放在 PWiki/publish/ 文件夹下. 为了对博客的 Markdown 源文件以及博客使用的主题进行备份, 参考 Wikitten 原作者的方法, 我在 Github 上创建了一个名为 Wiki-site 的仓库用于存储这些源文件. 具体方法是: 在 Github 上创建一个名为 Wiki-site 的新仓库; 在本地上的 PWiki/ 目录下使用 git init 命令; 修改 PWiki/ 项目中的 .gitignore 文件, 过滤掉那些不需要追踪版本的文件; 另外要注意的问题是, 由于 PWiki/themes/Wikitten 是个 git submodule, 在 PWiki/ 目录下直接使用 git add * 之类的命令可能会引起一些 Warning, 我的做法是到 PWiki/themes/Wikitten/ 目录下先用 git add/commit 等命令处理好后, 再回到 PWiki/ 目录使用 git add/commit 命令; 回到 PWiki/ 目录, 将上面的修改都 git add/commit; 将本地项目与远程服务器进行关联, git remote add origin git@github.com:xzml/Wiki-site.git (具体可以参考第 5 个博客) 执行 git pull origin master, 将远程服务器中的 master 分支和本地的 origin 合并, 防止冲突. 上面没有报错之后, 可以使用 git status 查看当前本地仓库是不是干净的, 如果是的话, 就可以使用 git push -u origin master 推送到 Github 上了. 上面的步骤其实已经将问题给搞定了, 这里记录一个我出现的问题: 我有多个 Github 账号, 即使设置了 PWiki/ 的 local user 为 xzml, 在使用 git push -u origin master 时, 仍会使用另一个 userb. 由于我访问 Github 使用的是 SSH, 这说明访问 `git@github.com时使用的是 userb, 为了使通过 SSH 访问git@github.com使用 xzml, 我直接修改PWiki/.git/config文件中的url = xzml:xzml/Wiki-site.git, 这是因为我在.ssh/config给通过 xzml 访问git@github.com这一行为设置了别名为xzml`. 参考资料 Mac 下 Hexo 和 GitHub-Pages 搭建个人博客（一） Mac 下 Hexo 和 GitHub-Pages 搭建个人博客（二） macOS环境下利用Github和Hexo部署博客 使用 Hexo 生成静态博客过程记录 使用Git命令把本地项目上传到Github托管","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"关于Wiki的主题","date":"2018-11-25T14:35:41.000Z","path":"wiki/某些Tricks/关于Wiki的主题/","text":"不可思议的 Tricks比如使用 Markdown 中的列表, 像如下代码是不会显示列表前面的点 $\\bullet$: 1+ `a` 是一个数组 效果如下: a 是一个数组 需要写成: 1+ 参数 `a` 是一个数组. 才能得到想要的效果: 参数 a 是一个数组. 修改 Wikitten 模板的属性修改字体可以去 themes/Wikitten/source/css 目录下, 查看 style.styl 文件, 发现其中还会导入 _variables.styl 文件, 只需要修改该文件中的相关属性即可. 修改代码使用的主题当前我使用的代码主题 (配色) 是 solarized-light, 要查看其它的配色, 可以看 themes/Wikitten/source/css/_highlight 目录, 里面有大量的配色文件, 这些文件的文件名就是某种主题, 只需要将文件名填入 themes/Wikitten/_config.yml 中的 highlight 项目下即可. 比如: 1highlight: solarized-dark # monakai 参考资料参考资料中有 Wikitten 主题的地址, 以及原作者写的关于使用 Hexo 搭建个人 Wiki 的博客. 使用 Hexo 做个人 Wiki 知识管理系统 作者的个人 Wiki 地址 Wikitten 主题地址","tags":[{"name":"Tricks","slug":"Tricks","permalink":"http://yoursite.com/tags/Tricks/"}],"categories":[{"name":"某些Tricks","slug":"某些Tricks","permalink":"http://yoursite.com/categories/某些Tricks/"}]},{"title":"numpy中的random函数","date":"2018-11-25T11:41:45.000Z","path":"wiki/程序语言/Python/Numpy/numpy中的random函数/","text":"Random Datanp.random.rand1np.random.rand(d0, d1, ..., dn) rand 函数根据给定的维度产生 $[0, 1)$ 之间的随机数, 服从均匀分布 (uniform distribution) np.random.randn1np.random.randn(d0, d1, ..., dn) randn 函数返回服从标准正态分布 ($\\mathcal{N}(0, 1)$) 的随机数, 要返回服从 $\\mathcal{N}(\\mu, \\sigma)$ 的样本, 使用 $\\mu * \\text{np.random.randn(…)} + \\sigma$. np.random.randint1np.random.randint(low[, high, size, type]) 返回 $[low, high)$ 范围内的随机整数, 当 high 没有填写时, 默认产生 $[0, low)$ 范围内的随机整数. 默认类型为 np.int. np.random.random_integers1np.random.random_integers(low[, high, size]) 返回 $[low, high]$ 范围内的随机整数, 当 high 没有填写时, 默认生成随机数的范围为 $[1, low]$. 该函数在新版本的 numpy 中已被替代, 建议使用 randint 函数. 生成 [0, 1) 区间的浮点数1234np.random.random(size=None)np.random.sample(size=None)np.random.ranf(size=None)np.random.random_sample(size=None) 以上四个函数都是返回 $[0.0, 1.0)$ 范围内的随机浮点数. 如果要产生服从 $\\text{Unif}(b, a), b &gt; a$ 分布的浮点数, 可以使用 $(b - a) * \\text{random_sample()} + a$. np.random.choice1np.random.choice(a, size=None, replace=True, p=None) 从给定的 一维 数组中随机选取一个样本 参数 a 是整数时, 相当于 np.arange(a). size 为返回数组的大小, 用 tuple 表示. 参数 p 表示数组中数据出现的概率, 数组之和应该为 1, 并且大小要和 a 一样大. replace=False 时, 生成的随机数不能有重复的数值, 这是一个测试 例如: 12345678&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.random.choice(5, size=(3,), replace=False)array([1, 2, 0])&gt;&gt;&gt; np.random.choice(5, size=(6,), replace=False)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"mtrand.pyx\", line 1166, in mtrand.RandomState.choiceValueError: Cannot take a larger sample than population when 'replace=False' Permutationsnp.random.permutation1np.random.permutation(x) 对序列进行随机的非原地排列 (即不是 in-place 的, 会对序列进行拷贝). 如果序列是多维数组, 那么只会沿着第一个 index 进行随机排列. 参数 x 如果是个整数, 那么相当于对 np.arange(x) 进行随机排列. 考虑多维数组的情况, 见下面的例子: 12345&gt;&gt;&gt; a = np.arange(9).reshape(3, 3)&gt;&gt;&gt; np.random.permutation(a)array([[3, 4, 5], [0, 1, 2], [6, 7, 8]]) np.random.shuffle1np.random.shuffle() 对数组/list 进行原地 shuffle. 注意这个函数直接修改数组, 返回 None. 对于多维数组, 只会沿着第一个 index 进行 shuffle. 123456789&gt;&gt;&gt; aarray([[0, 1, 2], [3, 4, 5], [6, 7, 8]])&gt;&gt;&gt; np.random.shuffle(a)&gt;&gt;&gt; aarray([[3, 4, 5], [6, 7, 8], [0, 1, 2]]) Distributionsnp.random.normal1np.random.normal(loc=0.0, scale=1.0, size=None) 对正态 (高斯) 分布进行采样. $$p ( x ) = \\frac { 1 } { \\sqrt { 2 \\pi \\sigma ^ { 2 } } } e ^ { - \\frac { ( x - \\mu ) ^ { 2 } } { 2 \\sigma ^ { 2 } } }$$ 其中 $\\mu$ 称为 mean, 而 $\\sigma$ 称为 standard deviation, $\\sigma^2$ 被称为 variance. 123456&gt;&gt;&gt; mu, sigma = 0, 0.1 # mean and standard deviation&gt;&gt;&gt; s = np.random.normal(mu, sigma, 1000)&gt;&gt;&gt; abs(mu - np.mean(s)) &lt; 0.01True&gt;&gt;&gt; abs(sigma - np.std(s, ddof=1)) &lt; 0.01True np.random.uniform1np.random.uniform(low=0.0, high=1.0, size=None) 对均匀分布进行采样. low 和 size 是可选的. Random Generatornp.random.seed1np.random.seed(seed=None) 设置随机种子, 使结果可重复. 参考资料 为什么你用不好Numpy的random函数? Random sampling (numpy.random)","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Numpy","slug":"Numpy","permalink":"http://yoursite.com/tags/Numpy/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"http://yoursite.com/categories/程序语言/"},{"name":"Python","slug":"程序语言/Python","permalink":"http://yoursite.com/categories/程序语言/Python/"},{"name":"Numpy","slug":"程序语言/Python/Numpy","permalink":"http://yoursite.com/categories/程序语言/Python/Numpy/"}]}]}